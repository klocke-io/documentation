import{_ as t,c as a,o,a2 as i}from"./chunks/framework.B8WFj13S.js";const p=JSON.parse('{"title":"Validating Etcd Clusters","description":"","frontmatter":{"github_repo":"https://github.com/gardener/etcd-druid","github_subdir":"docs/usage","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/other-components/etcd-druid/validating-etcd-clusters.md","to":"validating-etcd-clusters.md"},"persona":"Users","title":"Validating Etcd Clusters","prev":false,"next":false},"headers":[],"relativePath":"docs/other-components/etcd-druid/validating-etcd-clusters/index.md","filePath":"docs/other-components/etcd-druid/validating-etcd-clusters.md","lastUpdated":null}'),d={name:"docs/other-components/etcd-druid/validating-etcd-clusters/index.md"};function s(c,e,r,l,n,h){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="crd-validations-for-etcd" tabindex="-1">CRD Validations for etcd <a class="header-anchor" href="#crd-validations-for-etcd" aria-label="Permalink to &quot;CRD Validations for etcd&quot;">​</a></h1><ul><li>The validations for the fields within the <code>etcd</code> resource are done via <a href="https://book.kubebuilder.io/reference/markers/crd-validation" target="_blank" rel="noreferrer">kubebuilder markers for CRD validation</a>.</li><li>The validations for clusters with kubernetes versions <code>&gt;= 1.29</code> are written using a combination of <a href="https://kubernetes.io/docs/reference/using-api/cel/" target="_blank" rel="noreferrer">CEL expressions</a> via the <code>x-validation</code> tag which provides a straightforward syntax to write validation rules for the fields, and pattern matching with the use of the <code>validation</code> tag.</li><li>The validations for clusters with kubernetes versions <code>&lt; 1.29</code> will not contain validations via <code>CEL</code> expressions since this is GA for kubernetes version 1.29 or higher.</li><li>Upon any changes to the validation rules to the etcd resource, the <code>yaml</code> files for the same can be generated by running the <code>make generate</code> command.</li></ul><h2 id="validation-rules" tabindex="-1">Validation rules: <a class="header-anchor" href="#validation-rules" aria-label="Permalink to &quot;Validation rules:&quot;">​</a></h2><h3 id="type-validation-rules" tabindex="-1">Type Validation rules: <a class="header-anchor" href="#type-validation-rules" aria-label="Permalink to &quot;Type Validation rules:&quot;">​</a></h3><p>The validations for fields of types <code>Duration</code>(metav1.Duration) and <code>cron</code> expressions are done via <code>regex</code> matching. These use the <code>validation:Pattern</code> marker.(The checking for the <code>Quantity</code>(resource.Quantity) fields are done by default, hence, no explicit validation is needed for the fields of this type):</p><ul><li><p>Duration fields: <code>&#39;^([0-9]+([.][0-9]+)?h)?([0-9]+([.][0-9]+)?m)?([0-9]+([.][0-9]+)?s)?([0-9]+([.][0-9]+)?d)?$&#39;)</code></p></li><li><p>Cron expression: <code>^(\\*|[1-5]?[0-9]|[1-5]?[0-9]-[1-5]?[0-9]|(?:[1-9]|[1-4][0-9]|5[0-9])\\/(?:[1-9]|[1-4][0-9]|5[0-9]|60)|\\*\\/(?:[1-9]|[1-4][0-9]|5[0-9]|60))\\s+(\\*|[0-9]|1[0-9]|2[0-3]|[0-9]-(?:[0-9]|1[0-9]|2[0-3])|1[0-9]-(?:1[0-9]|2[0-3])|2[0-3]-2[0-3]|(?:[1-9]|1[0-9]|2[0-3])\\/(?:[1-9]|1[0-9]|2[0-4])|\\*\\/(?:[1-9]|1[0-9]|2[0-4]))\\s+(\\*|[1-9]|[12][0-9]|3[01]|[1-9]-(?:[1-9]|[12][0-9]|3[01])|[12][0-9]-(?:[12][0-9]|3[01])|3[01]-3[01]|(?:[1-9]|[12][0-9]|30)\\/(?:[1-9]|[12][0-9]|3[01])|\\*\\/(?:[1-9]|[12][0-9]|3[01]))\\s+(\\*|[1-9]|1[0-2]|[1-9]-(?:[1-9]|1[0-2])|1[0-2]-1[0-2]|(?:[1-9]|1[0-2])\\/(?:[1-9]|1[0-2])|\\*\\/(?:[1-9]|1[0-2]))\\s+(\\*|[1-7]|[1-6]-[1-7]|[1-6]\\/[1-7]|\\*\\/[1-7])$</code></p><ul><li><strong>NOTE</strong>: The provided regex does not account for <code>special strings</code> such as <code>@yearly</code> or <code>@monthly</code>. Additionally, it fails to invalidate cases involving the <code>step operator (x/y)</code> and the <code>range operator (x-y)</code>, where the cron expression is considered valid even if <code>x &gt; y</code>. Please ensure these values are validated before passing the expression.</li></ul></li></ul><h3 id="update-validations" tabindex="-1">Update validations <a class="header-anchor" href="#update-validations" aria-label="Permalink to &quot;Update validations&quot;">​</a></h3><p>These validations are triggered when an update operation is done on the etcd resource.</p><ul><li><p>Immutable fields: The fields <code>etcd.spec.StorageClass</code> , <code>etcd.spec.StorageCapacity</code> and <code>etcd.spec.VolumeClaimTemplate</code> are immutable. The immutability is enforced by the CEL expression : <code>self == oldSelf</code>.</p></li><li><p>The value set for the field <code>etcd.spec.replicas</code> can either be decreased to <code>0</code> or increased. This is enforced by the CEL expression: <code>self==0 ? true : self &lt; oldSelf ? false : true</code></p></li></ul><h3 id="field-validations" tabindex="-1">Field validations <a class="header-anchor" href="#field-validations" aria-label="Permalink to &quot;Field validations&quot;">​</a></h3><ul><li>The fields which expect only a particular set of values are checked by using the kubebuilder marker: <code>+kubebuilder:validation:Enum=&lt;value1&gt;;&lt;value2&gt;</code><ul><li>The <code>etcd.spec.etcd.metrics</code> can only be set as either <code>basic</code> or <code>extensive</code>.</li><li>The <code>etcd.spec.backup.garbageCollectionPolicy</code> can only be set as <code>Exponential</code> or <code>LimitBased</code></li><li>The <code>etcd.spec.backup.compression.policy</code> can only be set as either <code>gzip</code> or <code>lzw</code> or <code>zlib</code>.</li><li>The <code>etcd.spec.sharedConfig.autoCompactionMode</code> can only be set as either <code>periodic</code> or <code>revision</code>.</li></ul></li></ul><ul><li><p>The value of <code>etcd.spec.backup.garbageCollectionPeriod</code> must be greater than <code>etcd.spec.backup.deltaSnapshotPeriod</code>. This is enforced by the CEL expression <code>!(has(self.deltaSnapshotPeriod) &amp;&amp; has(self.garbageCollectionPeriod)) || duration(self.deltaSnapshotPeriod).getSeconds() &lt; duration(self.garbageCollectionPeriod).getSeconds()</code>. The first part of the expression ensures that both the fields are present and then compares the values of the garbageCollectionPeriod and deltaSnapshotPeriod fields, if not, skips the check.</p></li><li><p>The value of <code>etcd.spec.StorageCapacity</code> must be more than 3 times that of the <code>etcd.spec.etcd.quota</code> if backups are enabled. If not, the value must be greater than that of the <code>etcd.spec.etcd.quota</code> field. This is enforced by using the CEL expression: <code>has(self.storageCapacity) &amp;&amp; has(self.etcd.quota) ? (has(self.backup.store) ? quantity(self.storageCapacity).compareTo(quantity(self.etcd.quota).add(quantity(self.etcd.quota)).add(quantity(self.etcd.quota))) &gt; 0 : quantity(self.storageCapacity).compareTo(quantity(self.etcd.quota)) &gt; 0 ): true</code> The check for whether backups are enabled or not is done by checking if the field <code>etcd.spec.backup.store</code> exists.</p></li></ul>',12)]))}const f=t(d,[["render",s]]);export{p as __pageData,f as default};
