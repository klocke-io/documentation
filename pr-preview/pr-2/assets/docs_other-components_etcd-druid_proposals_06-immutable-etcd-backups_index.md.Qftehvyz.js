import{_ as t,c as a,o as i,a2 as s}from"./chunks/framework.Bfq10Vlj.js";const u=JSON.parse('{"title":"Immutable etcd Cluster Backups","description":"","frontmatter":{"authors":["@seshachalam-yv","@renormalize","@ishan16696"],"creation-date":"2024-09-25","dep-number":6,"github_repo":"https://github.com/gardener/etcd-druid","github_subdir":"docs/proposals","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups.md","to":"06-immutable-etcd-backups.md"},"reviewers":["@etcd-druid-maintainers"],"status":"implementable","title":"Immutable etcd Cluster Backups","prev":false,"next":false},"headers":[],"relativePath":"docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups/index.md","filePath":"docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups.md","lastUpdated":null}'),o={name:"docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups/index.md"};function n(r,e,l,c,d,p){return i(),a("div",null,e[0]||(e[0]=[s(`<h1 id="dep-06-immutable-etcd-cluster-backups" tabindex="-1">DEP-06: Immutable etcd Cluster Backups <a class="header-anchor" href="#dep-06-immutable-etcd-cluster-backups" aria-label="Permalink to &quot;DEP-06: Immutable etcd Cluster Backups&quot;">​</a></h1><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>This proposal introduces immutable backups for etcd clusters managed by <code>etcd-druid</code>. By leveraging cloud provider immutability features, backups taken by <code>etcd-backup-restore</code> can neither be modified nor deleted once created for a configurable retention duration (immutability period). This approach strengthens the reliability and fault tolerance of the etcd restoration process.</p><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h2><ul><li><strong>etcd-druid:</strong> An etcd operator that configures, provisions, reconciles, and monitors etcd clusters.</li><li><strong>etcd-backup-restore:</strong> A sidecar container that manages backups and restores of etcd cluster state. For more information, see the <a href="https://github.com/gardener/etcd-backup-restore/blob/master/README.md" target="_blank" rel="noreferrer">etcd-backup-restore</a> documentation.</li><li><strong>WORM (Write Once, Read Many):</strong> A storage model in which data, once written, cannot be modified or deleted until certain conditions are met.</li><li><strong>Immutability:</strong> The property of an object that prevents it from being modified or deleted after creation.</li><li><strong>Immutability Period:</strong> The duration for which data must remain immutable before it can be modified or deleted.</li><li><strong>Bucket-Level Immutability:</strong> A policy that applies a uniform immutability period to all objects within a bucket.</li><li><strong>Object-Level Immutability:</strong> A policy that allows setting immutability periods individually for objects within a bucket, offering more granular control.</li><li><strong>Garbage Collection:</strong> The process of deleting old snapshot data that is no longer needed, in order to free up storage space. For more information, see the <a href="https://github.com/gardener/etcd-backup-restore/blob/master/docs/usage/garbage_collection.md" target="_blank" rel="noreferrer">garbage collection documentation</a>.</li><li><strong>Hibernation:</strong> A state in which an etcd cluster is scaled down to zero replicas, effectively pausing its operations. This is typically done to save costs when the cluster is not needed for an extended period. During hibernation, the cluster&#39;s data remains intact, and it can be resumed to its previous state when required.</li></ul><h2 id="motivation" tabindex="-1">Motivation <a class="header-anchor" href="#motivation" aria-label="Permalink to &quot;Motivation&quot;">​</a></h2><p><code>etcd-druid</code> provisions etcd clusters and manages their lifecycle. For every etcd cluster, consumers can enable periodic backups of the cluster state by configuring the <code>spec.backup</code> section in an Etcd custom resource. Periodic backups are taken via the <code>etcd-backup-restore</code> sidecar container that runs in each etcd member pod.</p><p>Periodic backups of an etcd cluster state ensure the ability to recover from a data loss or a quorum loss, enhancing reliability and fault tolerance. It is crucial that these backups, which are vital for restoring the etcd cluster, remain protected from any form of tampering, whether intentional or accidental. To safeguard the integrity of these backups, the authors recommend utilizing <code>WORM</code> protection, a feature offered by various cloud providers, to ensure the backups remain immutable and secure.</p><h3 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to &quot;Goals&quot;">​</a></h3><ul><li>Protect backup data against modifications and deletions post-creation through immutability policies offered by storage providers.</li></ul><h3 id="non-goals" tabindex="-1">Non-Goals <a class="header-anchor" href="#non-goals" aria-label="Permalink to &quot;Non-Goals&quot;">​</a></h3><ul><li>Implementing a mechanism to signal hibernation intent for handling snapshot immutability for hibernated etcd clusters, such as adding functionality via <code>etcd.spec</code> or annotations on the <code>Etcd</code> CR, to indicate when an etcd cluster should enter or exit hibernation, as discussed in <a href="https://github.com/gardener/etcd-druid/issues/922" target="_blank" rel="noreferrer">gardener/etcd-druid#922</a>.</li><li>Supporting immutable backups on storage providers that do not offer immutability features (e.g., OpenStack Swift).</li></ul><h2 id="proposal" tabindex="-1">Proposal <a class="header-anchor" href="#proposal" aria-label="Permalink to &quot;Proposal&quot;">​</a></h2><p>This proposal aims to improve backup storage integrity and security by using immutability features available on major cloud providers.</p><h3 id="supported-cloud-providers" tabindex="-1">Supported Cloud Providers <a class="header-anchor" href="#supported-cloud-providers" aria-label="Permalink to &quot;Supported Cloud Providers&quot;">​</a></h3><ul><li><strong>Google Cloud Storage (GCS):</strong> <a href="https://cloud.google.com/storage/docs/bucket-lock" target="_blank" rel="noreferrer">Bucket Lock</a></li><li><strong>Amazon S3 (S3):</strong> <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html" target="_blank" rel="noreferrer">Object Lock</a></li><li><strong>Azure Blob Storage (ABS):</strong> <a href="https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal" target="_blank" rel="noreferrer">Immutable Blob Storage</a></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Currently, Openstack object storage (swift) doesn&#39;t support immutability for objects: <a href="https://blueprints.launchpad.net/swift/+spec/immutability-middleware" target="_blank" rel="noreferrer">https://blueprints.launchpad.net/swift/+spec/immutability-middleware</a>.</p></div><h4 id="types-of-immutability" tabindex="-1">Types of Immutability <a class="header-anchor" href="#types-of-immutability" aria-label="Permalink to &quot;Types of Immutability&quot;">​</a></h4><ol><li><strong>Object-Level Immutability:</strong> Allows setting immutability periods independently for each object within a bucket.</li><li><strong>Bucket-Level Immutability:</strong> Applies a uniform immutability policy to all objects in a bucket.</li></ol><h3 id="comparison-of-bucket-level-and-object-level-immutability" tabindex="-1">Comparison of Bucket-Level and Object-Level Immutability <a class="header-anchor" href="#comparison-of-bucket-level-and-object-level-immutability" aria-label="Permalink to &quot;Comparison of Bucket-Level and Object-Level Immutability&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Feature</th><th>GCS</th><th>S3</th><th>ABS</th></tr></thead><tbody><tr><td>Can bucket-level immutability period be increased?</td><td>Yes</td><td>Yes*</td><td>Yes (only 5 times)</td></tr><tr><td>Can bucket-level immutability period be decreased?</td><td>No</td><td>Yes*</td><td>No</td></tr><tr><td>Is bucket-level immutability a prerequisite for object-level immutability?</td><td>No</td><td>Yes</td><td>Yes (for existing buckets)</td></tr><tr><td>Can object-level immutability period be increased?</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Can object-level immutability period be decreased?</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Support for enabling object-level immutability in existing buckets</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Support for enabling object-level immutability in new buckets</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Support for enabling bucket-level immutability in existing buckets</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Support for enabling bucket-level immutability in new buckets</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Precedence between bucket-level and object-level immutability periods</td><td>Max(bucket, object)</td><td>Object-level</td><td>Max(bucket, object)</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>In AWS S3, it is possible to increase and decrease the bucket-level immutability period; however, this action can be blocked by configuring specific bucket policy settings.<br> For GCS, object-level immutability is not yet supported for existing buckets; see <a href="https://issuetracker.google.com/issues/346679415?pli=1" target="_blank" rel="noreferrer">this issue</a>.</p></div><h3 id="recommended-approach" tabindex="-1">Recommended Approach <a class="header-anchor" href="#recommended-approach" aria-label="Permalink to &quot;Recommended Approach&quot;">​</a></h3><p>At the time of writing this proposal, these are the current limitations seen across providers:</p><ul><li><strong>S3 and ABS:</strong> typically require bucket-level immutability as a prerequisite for object-level immutability.</li><li><strong>GCS</strong> does not currently support object-level immutability in existing buckets.</li><li><strong>ABS</strong> requires a <a href="https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-version-level-worm-policies#migration" target="_blank" rel="noreferrer">migration process</a> to enable version-level immutability on existing containers.</li></ul><p>Consequently, the authors recommend <strong>bucket-level immutability</strong>. This approach simplifies configuration and ensures a uniform immutability policy for all backups in a bucket across all support providers.</p><h3 id="configuring-immutable-backups" tabindex="-1">Configuring Immutable Backups <a class="header-anchor" href="#configuring-immutable-backups" aria-label="Permalink to &quot;Configuring Immutable Backups&quot;">​</a></h3><p>Creating and configuring immutable buckets on providers is not handled by <code>etcd-druid</code> and must be done by the consumers. For a large-scale consumer like Gardener, provider extensions are leveraged to automate both the creation and configuration of buckets. For more details, see <a href="https://github.com/gardener/gardener/blob/75dd7c7488b31d87dc8c683f8ed2ef6aaa12d283/docs/extensions/resources/backupbucket.md" target="_blank" rel="noreferrer">BackupBucket</a> and refer to <a href="https://github.com/gardener/gardener/issues/10866" target="_blank" rel="noreferrer">this issue</a>.</p><h4 id="prerequisites" tabindex="-1">Prerequisites <a class="header-anchor" href="#prerequisites" aria-label="Permalink to &quot;Prerequisites&quot;">​</a></h4><ol><li><p><strong>Configure or Update the Immutable Bucket</strong></p><ul><li>Use your cloud provider’s CLI, SDK, or console to create (or update) a bucket/container with a WORM (write-once-read-many) immutability policy.</li><li>Refer to the <a href="https://github.com/gardener/etcd-backup-restore/blob/master/docs/usage/enabling_immutable_snapshots.md#configure-bucket-level-immutability" target="_blank" rel="noreferrer">Configure Bucket-Level Immutability</a> for step-by-step instructions on configuring or updating the immutable bucket across different cloud providers.</li></ul></li><li><p><strong>Provide Valid Credentials in a Kubernetes Secret</strong></p></li></ol><ul><li>The <code>store</code> section of the <code>Etcd</code> CR must reference a <code>Secret</code> containing valid credentials.<div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">druid.gardener.cloud/v1alpha1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Etcd</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">example-etcd</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> backup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    prefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">etcd-backups</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">my-immutable-backups</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Bucket name</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">aws</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # Supported: aws, gcp, azure</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    secretRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">     name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">etcd-backup-credentials</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Reference to the Secret</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    immutability</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">     retentionType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bucket</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # Enables bucket-level immutability</span></span></code></pre></div></li><li>Confirm that this secret has the proper permissions to upload and retrieve snapshots from the immutable bucket.</li><li>See the <a href="/docs/other-components/etcd-druid/deployment/getting-started-locally/getting-started-locally/#setting-up-cloud-provider-object-store-secret">Getting Started guide</a> for an example.</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>The <code>etcd-druid</code> does not handle the rotation of cloud provider credentials. Credential rotation must be managed by the operator.</p></div><p>By following these steps, you will have set up an immutable bucket for storing etcd backups, along with the necessary references in your <code>Etcd</code> specification and Kubernetes secret.</p><h3 id="handling-of-hibernated-clusters" tabindex="-1">Handling of Hibernated Clusters <a class="header-anchor" href="#handling-of-hibernated-clusters" aria-label="Permalink to &quot;Handling of Hibernated Clusters&quot;">​</a></h3><p>When an etcd cluster remains hibernated beyond the bucket’s immutability period, backups might become mutable again, depending on the cloud provider (see <a href="/docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups/#comparison-of-bucket-level-and-object-level-immutability">Comparison of Storage Provider Properties</a>). This could compromise the intended guarantees of immutability, exposing backups to accidental or malicious alterations.</p><p>As mentioned in <a href="https://github.com/gardener/etcd-druid/issues/922" target="_blank" rel="noreferrer">gardener/etcd-druid#922</a>, a clear hibernation signal is needed. Since <code>etcd-druid</code> does not currently support hibernation natively and addressing that is out of scope for this proposal, we focus solely on maintaining immutability.</p><h4 id="proposal-1" tabindex="-1">Proposal <a class="header-anchor" href="#proposal-1" aria-label="Permalink to &quot;Proposal&quot;">​</a></h4><p>To mitigate the risk of backups becoming mutable during extended hibernation under bucket-level immutability, the authors propose the following approach:</p><ol><li><p><strong>Prerequisite: Cut-off Traffic and Take a Final Full Snapshot Before Hibernation</strong></p><ul><li>Before scaling the etcd cluster down to zero replicas, the etcd controller removes etcd’s client ports (2379/2380) from the etcd Service to block application traffic.</li><li>The etcd controller then triggers an <a href="/docs/other-components/etcd-druid/proposals/05-etcd-operator-tasks/#trigger-on-demand-fulldelta-snapshot">on-demand full snapshot</a>. This ensures that the latest state of the etcd cluster is captured and securely stored before hibernation begins.</li></ul></li><li><p><strong>Periodically Re-Upload the Snapshot</strong></p><ul><li>Re-uploading the latest full snapshot resets its immutability period in the bucket, ensuring backups remain protected during hibernation.</li><li>By default, the re-upload schedule follows <code>etcd.spec.backup.fullSnapshotSchedule</code>. Currently, this interval cannot be customized exclusively for re-uploads; future enhancements may introduce a dedicated configuration parameter.</li><li>A new operator task type, <strong><code>ExtendFullSnapshotImmutabilityTask</code></strong>, periodically calls a new CLI command, <code>extend-snapshot-immutability</code>, to re-upload the snapshot and extend its immutability.</li><li><strong><code>ExtendFullSnapshotImmutabilityTask</code> also manages garbage collection</strong>, ensuring that <strong>only the latest immutable snapshots are retained</strong> while deleting older snapshots created by the task itself.</li></ul></li></ol><p>By capturing a final full snapshot before hibernation, periodically re-uploading it to preserve immutability, and removing stale backups, etcd backups remain safeguarded against accidental or malicious alterations until the cluster is resumed.</p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p><strong>Limitation:</strong> There is a potential edge case where a snapshot might become corrupted <strong>before hibernation</strong> or during the <strong>re-upload process by <code>ExtendFullSnapshotImmutabilityTask</code></strong>. If this happens, the process could repeatedly re-upload the same corrupted snapshot, failing to ensure a reliable backup.</p></div><p>An alternative solution could be to trigger the <a href="/docs/other-components/etcd-druid/proposals/02-snapshot-compaction/">snapshot compaction</a> which runs in separate pod and takes a fresh snapshot of the compacted etcd data and re-uploads it to the object store.</p><p>While this approach ensures that only valid snapshots are re-uploaded, it is <strong>resource-intensive</strong>, requiring an operational etcd instance even in hibernation. Given the high cost in terms of compute and memory, the authors <strong>recommend</strong> the snapshot re-upload approach as a more practical solution.</p><h5 id="etcd-cr-api-changes" tabindex="-1">Etcd CR API Changes <a class="header-anchor" href="#etcd-cr-api-changes" aria-label="Permalink to &quot;Etcd CR API Changes&quot;">​</a></h5><p>A new field is introduced in <code>Etcd.spec.backup.store</code> to indicate the immutability strategy:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// StoreSpec defines parameters for storing etcd backups.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StoreSpec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Immutability configuration for the backup store.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Immutability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ImmutabilitySpec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`json:&quot;immutability,omitempty&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ImmutabilitySpec defines immutability settings.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImmutabilitySpec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // RetentionType indicates the type of immutability approach. For example, &quot;bucket&quot;.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RetentionType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`json:&quot;retentionType,omitempty&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>If <code>immutability</code> is not specified, <code>etcd-druid</code> will assume that the bucket is mutable, and no immutability-related logic applies. We have defined a new type to allow us future enhancements to the immutability specification.</p><h5 id="etcd-backup-restore-enhancements" tabindex="-1"><code>etcd-backup-restore</code> Enhancements <a class="header-anchor" href="#etcd-backup-restore-enhancements" aria-label="Permalink to &quot;\`etcd-backup-restore\` Enhancements&quot;">​</a></h5><p>The authors propose adding new sub-command to the <code>etcd-backup-restore</code> CLI (<code>etcdbrctl</code>) to maintain immutability during hibernation and to clean up snapshots created by <code>ExtendFullSnapshotImmutabilityTask</code>:</p><ul><li><strong><code>extend-snapshot-immutability</code></strong><ul><li>Downloads the latest full snapshot from the object store.</li><li>Renames the snapshot (for instance, updates its Unix timestamp) to avoid overwriting an existing immutable snapshot.</li><li>Uploads the renamed snapshot back to object storage, thereby <strong>restarting</strong> its immutability timer.</li><li>Introduces the <code>--gc-from-timestamp=&lt;timestamp&gt;</code> parameter, where <code>&lt;timestamp&gt;</code> is the creation timestamp of the task. This ensures that only snapshots created by the task are subject to garbage collection.</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>As an alternative to the download/upload approach, the authors document the possibility of using provider APIs to perform a server-side object copy. This method could significantly reduce network costs and latency by directly copying the snapshot within the cloud provider&#39;s infrastructure. While this option is not implemented in the current version, feasibility of server-side copy can be explored in <a href="https://github.com/gardener/etcd-backup-restore/blob/master/pkg/types/snapstore.go#L74-L86" target="_blank" rel="noreferrer">etcd-backup-restore</a> during implementation.</p></div><h5 id="etcd-controller-enhancements" tabindex="-1">etcd Controller Enhancements <a class="header-anchor" href="#etcd-controller-enhancements" aria-label="Permalink to &quot;etcd Controller Enhancements&quot;">​</a></h5><p>When a hibernation flow is initiated (by external tooling or higher-level operators), the <a href="/docs/other-components/etcd-druid/controllers/#etcd-controller">etcd controller</a> can:</p><ol><li>Remove etcd’s client ports (2379/2380) from the etcd Service to block application traffic.</li><li>Trigger an <a href="/docs/other-components/etcd-druid/proposals/05-etcd-operator-tasks/#trigger-on-demand-fulldelta-snapshot">on-demand full snapshot</a> via an <code>EtcdOperatorTask</code>.</li><li>Scale down the <code>StatefulSet</code> replicas to zero, provided the previous snapshot step is successful.</li><li>Create the <code>ExtendFullSnapshotImmutabilityTask</code> if <code>etcd.spec.backup.store.immutability.retentionType</code> is <code>&quot;bucket&quot;</code> and based on <code>etcd.spec.backup.fullSnapshotSchedule</code>.</li></ol><h5 id="operator-task-enhancements" tabindex="-1">Operator Task Enhancements <a class="header-anchor" href="#operator-task-enhancements" aria-label="Permalink to &quot;Operator Task Enhancements&quot;">​</a></h5><p>The <code>ExtendFullSnapshotImmutabilityTask</code> will create a cron job that:</p><ul><li>Runs <code>etcdbrctl extend-snapshot-immutability --gc-from-timestamp=&lt;creation timestamp of task&gt;</code> to preserve the immutability period of the most recent snapshot. This command re-uploads the latest snapshot, effectively resetting its immutability period. Additionally, it removes any snapshots that have become mutable after the creation timestamp of the task.</li></ul><p>By periodically re-uploading (extending) the latest snapshot during hibernation, the authors ensure that the immutability period is extended, and the backups remain <strong>protected throughout the hibernation period</strong>.</p><h6 id="lifecycle-of-extendfullsnapshotimmutabilitytask" tabindex="-1">Lifecycle of <code>ExtendFullSnapshotImmutabilityTask</code> <a class="header-anchor" href="#lifecycle-of-extendfullsnapshotimmutabilitytask" aria-label="Permalink to &quot;Lifecycle of \`ExtendFullSnapshotImmutabilityTask\`&quot;">​</a></h6><p>The <code>ExtendFullSnapshotImmutabilityTask</code> is <strong>active during hibernation</strong> and is automatically managed by the <code>etcd-controller</code>. Its lifecycle is tied to the cluster’s hibernation state:</p><ol><li><p><strong>Task Creation</strong></p><ul><li>When the etcd cluster enters hibernation (e.g., scaling down to zero replicas), the etcd controller: <ul><li>Triggers a final full snapshot.</li><li>Creates the <code>ExtendFullSnapshotImmutabilityTask</code> to run <code>extend-snapshot-immutability --gc-from-timestamp=&lt;creation timestamp of this task&gt;</code></li></ul></li></ul></li><li><p><strong>Task Deletion</strong></p><ul><li>When the cluster resumes from hibernation (scales up to non-zero replicas), the controller: <ul><li>Deletes the <code>ExtendFullSnapshotImmutabilityTask</code> to stop extending snapshots.</li><li>Resumes the normal backup schedule defined in <code>spec.backup.fullSnapshotSchedule</code>.</li></ul></li><li>When the immutability configuration is removed from the <code>etcd.spec.backup.store</code>, the controller: <ul><li>Deletes the <code>ExtendFullSnapshotImmutabilityTask</code> to stop extending snapshots.</li></ul></li></ul></li></ol><h6 id="example-task-config" tabindex="-1">Example Task Config <a class="header-anchor" href="#example-task-config" aria-label="Permalink to &quot;Example Task Config&quot;">​</a></h6><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ExtendFullSnapshotImmutabilityTaskConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Schedule defines a cron schedule (e.g., &quot;0 0 * * *&quot;).</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Schedule </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`json:&quot;schedule,omitempty&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Sample YAML</strong>:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0 0 * * *&quot;</span></span></code></pre></div><h5 id="disabling-immutability" tabindex="-1">Disabling Immutability <a class="header-anchor" href="#disabling-immutability" aria-label="Permalink to &quot;Disabling Immutability&quot;">​</a></h5><p>If you remove the immutability configuration from <code>etcd.spec.backup.store</code>, hibernation-based immutability support no longer applies. However, once the bucket itself is locked at the provider level, <strong>it cannot be reverted to a mutable state</strong>. Any objects uploaded by <code>etcd-backup-restore</code> are still subject to the existing WORM policy.</p><p>If you genuinely require a mutable backup again, the recommended approach is:</p><ol><li><strong>Use a new bucket.</strong> In your <code>Etcd</code> custom resource, reference a different bucket that does <strong>not</strong> have immutability enabled.</li><li><strong>Use <code>EtcdCopyBackupsTask</code>.</strong> If you want to start the cluster with a new bucket but retain old data, use the <a href="https://github.com/gardener/etcd-druid/blob/master/examples/etcdcopybackstask/druid_v1alpha1_etcdcopybackupstask.yaml" target="_blank" rel="noreferrer"><code>EtcdCopyBackupsTask</code></a> to copy existing backups from the old immutable bucket to the new mutable bucket.</li><li><strong>Reconcile the <code>Etcd</code> CR.</strong> After pointing <code>etcd.spec.backup.store</code> to the new bucket, <code>etcd-druid</code> will start storing backups there.</li></ol><blockquote><p><strong>Note:</strong> Existing snapshots in the old immutable bucket remain locked according to the configured immutability period.</p></blockquote><h2 id="compatibility" tabindex="-1">Compatibility <a class="header-anchor" href="#compatibility" aria-label="Permalink to &quot;Compatibility&quot;">​</a></h2><p>These changes are compatible with existing etcd clusters and current backup processes.</p><ul><li><strong>Backward Compatibility:</strong><ul><li>Clusters without immutable buckets continue to function without any changes.</li></ul></li><li><strong>Forward Compatibility:</strong><ul><li>Clusters can opt in to use immutable backups by configuring the bucket accordingly (as described in <a href="/docs/other-components/etcd-druid/proposals/06-immutable-etcd-backups/#configuring-immutable-backups">Configuring Immutable Backups</a>) and setting <code>etcd.spec.backup.store.immutability.retentionType == &quot;bucket&quot;</code>.</li><li>The enhanced hibernation logic in the etcd controller is additive, meaning it does not interfere with existing workflows.</li></ul></li></ul><h3 id="impact-for-operators" tabindex="-1">Impact for Operators <a class="header-anchor" href="#impact-for-operators" aria-label="Permalink to &quot;Impact for Operators&quot;">​</a></h3><p>In scenarios where you want to exclude certain snapshots from an etcd restore, you previously could simply delete them from object storage. However, when bucket-level immutability is enabled, deleting existing immutable snapshots is no longer possible. To address this need, most cloud providers allow adding <strong>custom annotations or tags</strong> to objects—even immutable ones—so they can be logically excluded without physically removing them.</p><p><code>etcd-backup-restore</code> supports ignoring snapshots based on annotations or tags, rather than deleting them. Operators can add the following key-value pair to any snapshot object to exclude it from future restores:</p><ul><li><strong>Key:</strong> <code>x-etcd-snapshot-exclude</code></li><li><strong>Value:</strong> <code>true</code></li></ul><p>Because these tags or annotations do not modify the underlying snapshot data, they are permissible even for immutable objects. Once these annotations are in place, <code>etcd-backup-restore</code> will detect them and skip the tagged snapshots during restoration, thus preventing unwanted snapshots from being used. For more details, see the <a href="https://github.com/gardener/etcd-backup-restore/blob/master/docs/usage/enabling_immutable_snapshots.md#ignoring-snapshots-during-restoration" target="_blank" rel="noreferrer">Ignoring Snapshots during Restoration</a>.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>At the time of writing this proposal, this feature is not supported for AWS S3 buckets.</p></div><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://cloud.google.com/storage/docs/bucket-lock" target="_blank" rel="noreferrer">GCS Bucket Lock</a></li><li><a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html" target="_blank" rel="noreferrer">AWS S3 Object Lock</a></li><li><a href="https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal" target="_blank" rel="noreferrer">Azure Immutable Blob Storage</a></li><li><a href="https://github.com/gardener/etcd-backup-restore/blob/master/README.md" target="_blank" rel="noreferrer">etcd-backup-restore Documentation</a></li><li><a href="https://github.com/gardener/gardener/issues/10866" target="_blank" rel="noreferrer">Gardener Issue: 10866</a></li></ul><hr>`,82)]))}const m=t(o,[["render",n]]);export{u as __pageData,m as default};
