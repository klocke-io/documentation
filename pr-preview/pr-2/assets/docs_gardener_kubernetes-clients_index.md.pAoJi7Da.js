import{_ as t,c as s,o as i,a2 as a}from"./chunks/framework.B8WFj13S.js";const k=JSON.parse('{"title":"Kubernetes Clients","description":"","frontmatter":{"github_repo":"https://github.com/gardener/gardener","github_subdir":"docs/development","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/gardener/kubernetes-clients.md","to":"kubernetes-clients.md"},"persona":"Developers","title":"Kubernetes Clients","prev":false,"next":false},"headers":[],"relativePath":"docs/gardener/kubernetes-clients/index.md","filePath":"docs/gardener/kubernetes-clients.md","lastUpdated":null}'),n={name:"docs/gardener/kubernetes-clients/index.md"};function o(r,e,l,h,c,d){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="kubernetes-clients-in-gardener" tabindex="-1">Kubernetes Clients in Gardener <a class="header-anchor" href="#kubernetes-clients-in-gardener" aria-label="Permalink to &quot;Kubernetes Clients in Gardener&quot;">​</a></h1><p>This document aims at providing a general developer guideline on different aspects of using Kubernetes clients in a large-scale distributed system and project like Gardener. The points included here are not meant to be consulted as absolute rules, but rather as general rules of thumb that allow developers to get a better feeling about certain gotchas and caveats. It should be updated with lessons learned from maintaining the project and running Gardener in production.</p><h2 id="prerequisites" tabindex="-1">Prerequisites: <a class="header-anchor" href="#prerequisites" aria-label="Permalink to &quot;Prerequisites:&quot;">​</a></h2><p>Please familiarize yourself with the following basic Kubernetes API concepts first, if you&#39;re new to Kubernetes. A good understanding of these basics will help you better comprehend the following document.</p><ul><li><a href="https://kubernetes.io/docs/reference/using-api/api-concepts/" target="_blank" rel="noreferrer">Kubernetes API Concepts</a> (including terminology, watch basics, etc.)</li><li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/" target="_blank" rel="noreferrer">Extending the Kubernetes API</a> (including Custom Resources and aggregation layer / extension API servers)</li><li><a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="noreferrer">Extend the Kubernetes API with CustomResourceDefinitions</a></li><li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/" target="_blank" rel="noreferrer">Working with Kubernetes Objects</a></li><li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noreferrer">Sample Controller</a> (the diagram helps to build an understanding of an controller&#39;s basic structure)</li></ul><h2 id="client-types-client-go-generated-controller-runtime" tabindex="-1">Client Types: Client-Go, Generated, Controller-Runtime <a class="header-anchor" href="#client-types-client-go-generated-controller-runtime" aria-label="Permalink to &quot;Client Types: Client-Go, Generated, Controller-Runtime&quot;">​</a></h2><p>For historical reasons, you will find different kinds of Kubernetes clients in Gardener:</p><h3 id="client-go-clients" tabindex="-1">Client-Go Clients <a class="header-anchor" href="#client-go-clients" aria-label="Permalink to &quot;Client-Go Clients&quot;">​</a></h3><p><a href="https://github.com/kubernetes/client-go" target="_blank" rel="noreferrer">client-go</a> is the default/official client for talking to the Kubernetes API in Golang. It features the so called <a href="https://github.com/kubernetes/client-go/blob/release-1.21/kubernetes/clientset.go#L72" target="_blank" rel="noreferrer">&quot;client sets&quot;</a> for all built-in Kubernetes API groups and versions (e.g. <code>v1</code> (aka <code>core/v1</code>), <code>apps/v1</code>). client-go clients are generated from the built-in API types using <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/generating-clientset.md" target="_blank" rel="noreferrer">client-gen</a> and are composed of interfaces for every known API GroupVersionKind. A typical client-go usage looks like this:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx        </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c          </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubernetes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Interface</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;k8s.io/client-go/kubernetes&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  deployment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appsv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deployment</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &quot;k8s.io/api/apps/v1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">updatedDeployment, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AppsV1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deployments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, deployment, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">metav1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UpdateOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span></code></pre></div><p><em>Important characteristics of client-go clients:</em></p><ul><li>clients are specific to a given API GroupVersionKind, i.e., clients are hard-coded to corresponding API-paths (don&#39;t need to use the discovery API to map GVK to a REST endpoint path).</li><li>client&#39;s don&#39;t modify the passed in-memory object (e.g. <code>deployment</code> in the above example). Instead, they return a new in-memory object. This means that controllers have to continue working with the new in-memory object or overwrite the shared object to not lose any state updates.</li></ul><h3 id="generated-client-sets-for-gardener-apis" tabindex="-1">Generated Client Sets for Gardener APIs <a class="header-anchor" href="#generated-client-sets-for-gardener-apis" aria-label="Permalink to &quot;Generated Client Sets for Gardener APIs&quot;">​</a></h3><p>Gardener&#39;s APIs extend the Kubernetes API by registering an extension API server (in the garden cluster) and <code>CustomResourceDefinition</code>s (on Seed clusters), meaning that the Kubernetes API will expose additional REST endpoints to manage Gardener resources in addition to the built-in API resources. In order to talk to these extended APIs in our controllers and components, client-gen is used to generate client-go-style clients to <a href="https://github.com/gardener/gardener/tree/master/pkg/client" target="_blank" rel="noreferrer"><code>pkg/client/{core,extensions,seedmanagement,...}</code></a>.</p><p>Usage of these clients is equivalent to <code>client-go</code> clients, and the same characteristics apply. For example:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx   </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c     </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gardencoreclientset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Interface</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;github.com/gardener/gardener/pkg/client/core/clientset/versioned&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gardencorev1beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shoot</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // &quot;github.com/gardener/gardener/pkg/apis/core/v1beta1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">updatedShoot, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CoreV1beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shoots</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;garden-my-project&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shoot, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">metav1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UpdateOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span></code></pre></div><h3 id="controller-runtime-clients" tabindex="-1">Controller-Runtime Clients <a class="header-anchor" href="#controller-runtime-clients" aria-label="Permalink to &quot;Controller-Runtime Clients&quot;">​</a></h3><p><a href="https://github.com/kubernetes-sigs/controller-runtime" target="_blank" rel="noreferrer">controller-runtime</a> is a Kubernetes community project (<a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noreferrer">kubebuilder</a> subproject) for building controllers and operators for custom resources. Therefore, it features a generic client that follows a different approach and does not rely on generated client sets. Instead, the client can be used for managing any Kubernetes resources (built-in or custom) homogeneously. For example:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx        </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c          </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  deployment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appsv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deployment</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // &quot;k8s.io/api/apps/v1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shoot      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gardencorev1beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shoot</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;github.com/gardener/gardener/pkg/apis/core/v1beta1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, deployment)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shoot)</span></span></code></pre></div><p>A brief introduction to controller-runtime and its basic constructs can be found at the <a href="https://pkg.go.dev/sigs.k8s.io/controller-runtime" target="_blank" rel="noreferrer">official Go documentation</a>.</p><p><em>Important characteristics of controller-runtime clients:</em></p><ul><li>The client functions take a generic <code>client.Object</code> or <code>client.ObjectList</code> value. These interfaces are implemented by all Golang types, that represent Kubernetes API objects or lists respectively which can be interacted with via usual API requests. [1]</li><li>The client first consults a <code>runtime.Scheme</code> (configured during client creation) for recognizing the object&#39;s <code>GroupVersionKind</code> (this happens on the client-side only). A <code>runtime.Scheme</code> is basically a registry for Golang API types, defaulting and conversion functions. Schemes are usually provided per <code>GroupVersion</code> (see <a href="https://github.com/kubernetes/api/blob/release-1.21/apps/v1/register.go" target="_blank" rel="noreferrer">this example</a> for <code>apps/v1</code>) and can be combined to one single scheme for further usage (<a href="https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L96" target="_blank" rel="noreferrer">example</a>). In controller-runtime clients, schemes are used only for mapping a typed API object to its <code>GroupVersionKind</code>.</li><li>It then consults a <code>meta.RESTMapper</code> (also configured during client creation) for mapping the <code>GroupVersionKind</code> to a <code>RESTMapping</code>, which contains the <code>GroupVersionResource</code> and <code>Scope</code> (namespaced or cluster-scoped). From these values, the client can unambiguously determine the REST endpoint path of the corresponding API resource. For instance: <code>appsv1.DeploymentList</code> is available at <code>/apis/apps/v1/deployments</code> or <code>/apis/apps/v1/namespaces/&lt;namespace&gt;/deployments</code> respectively. <ul><li>There are different <code>RESTMapper</code> implementations, but generally they are talking to the API server&#39;s discovery API for retrieving <code>RESTMappings</code> for all API resources known to the API server (either built-in, registered via API extension or <code>CustomResourceDefinition</code>s).</li><li>The default implementation of a controller-runtime (which Gardener uses as well) is the <a href="https://github.com/kubernetes-sigs/controller-runtime/blob/v0.9.0/pkg/client/apiutil/dynamicrestmapper.go#L77" target="_blank" rel="noreferrer">dynamic <code>RESTMapper</code></a>. It caches discovery results (i.e. <code>RESTMappings</code>) in-memory and only re-discovers resources from the API server when a client tries to use an unknown <code>GroupVersionKind</code>, i.e., when it encounters a <code>No{Kind,Resource}MatchError</code>.</li></ul></li><li>The client writes back results from the API server into the passed in-memory object. <ul><li>This means that controllers don&#39;t have to worry about copying back the results and should just continue to work on the given in-memory object.</li><li>This is a nice and flexible pattern, and helper functions should try to follow it wherever applicable. Meaning, if possible accept an object param, pass it down to clients and keep working on the same in-memory object instead of creating a new one in your helper function.</li><li>The benefit is that you don&#39;t lose updates to the API object and always have the last-known state in memory. Therefore, you don&#39;t have to read it again, e.g., for getting the current <code>resourceVersion</code> when working with <a href="/documentation/pr-preview/pr-2/docs/gardener/kubernetes-clients/#conflicts-concurrency-control-and-optimistic-locking">optimistic locking</a>, and thus minimize the chances for running into conflicts.</li><li>However, controllers <em>must not</em> use the same in-memory object concurrently in multiple goroutines. For example, decoding results from the API server in multiple goroutines into the same maps (e.g., labels, annotations) will cause panics because of &quot;concurrent map writes&quot;. Also, reading from an in-memory API object in one goroutine while decoding into it in another goroutine will yield non-atomic reads, meaning data might be corrupt and represent a non-valid/non-existing API object.</li><li>Therefore, if you need to use the same in-memory object in multiple goroutines concurrently (e.g., shared state), remember to leverage proper synchronization techniques like channels, mutexes, <code>atomic.Value</code> and/or copy the object prior to use. The average controller however, will not need to share in-memory API objects between goroutines, and it&#39;s typically an indicator that the controller&#39;s design should be improved.</li></ul></li><li>The client decoder erases the object&#39;s <code>TypeMeta</code> (<code>apiVersion</code> and <code>kind</code> fields) after retrieval from the API server, see <a href="https://github.com/kubernetes/kubernetes/issues/80609" target="_blank" rel="noreferrer">kubernetes/kubernetes#80609</a>, <a href="https://github.com/kubernetes-sigs/controller-runtime/issues/1517" target="_blank" rel="noreferrer">kubernetes-sigs/controller-runtime#1517</a>. Unstructured and metadata-only requests objects are an exception to this because the contained <code>TypeMeta</code> is the only way to identify the object&#39;s type. Because of this behavior, <code>obj.GetObjectKind().GroupVersionKind()</code> is likely to return an empty <code>GroupVersionKind</code>. I.e., you must not rely on <code>TypeMeta</code> being set or <code>GetObjectKind()</code> to return something usable. If you need to identify an object&#39;s <code>GroupVersionKind</code>, use a scheme and its <code>ObjectKinds</code> function instead (or the helper function <code>apiutil.GVKForObject</code>). This is not specific to controller-runtime clients and applies to client-go clients as well.</li></ul><p>[1] Other lower level, config or internal API types (e.g., such as <a href="https://github.com/kubernetes/api/blob/release-1.21/admission/v1/types.go#L29" target="_blank" rel="noreferrer"><code>AdmissionReview</code></a>) don&#39;t implement <code>client.Object</code>. However, you also can&#39;t interact with such objects via the Kubernetes API and thus also not via a client, so this can be disregarded at this point.</p><h3 id="metadata-only-clients" tabindex="-1">Metadata-Only Clients <a class="header-anchor" href="#metadata-only-clients" aria-label="Permalink to &quot;Metadata-Only Clients&quot;">​</a></h3><p>Additionally, controller-runtime clients can be used to easily retrieve metadata-only objects or lists. This is useful for efficiently checking if at least one object of a given kind exists, or retrieving metadata of an object, if one is not interested in the rest (e.g., spec/status). The <code>Accept</code> header sent to the API server then contains <code>application/json;as=PartialObjectMetadataList;g=meta.k8s.io;v=v1</code>, which makes the API server only return metadata of the retrieved object(s). This saves network traffic and CPU/memory load on the API server and client side. If the client fully lists all objects of a given kind including their spec/status, the resulting list can be quite large and easily exceed the controllers available memory. That&#39;s why it&#39;s important to carefully check if a full list is actually needed, or if metadata-only list can be used instead.</p><p>For example:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx       </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c         </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                         // &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shootList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">metav1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PartialObjectMetadataList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shootList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SetGroupVersionKind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gardencorev1beta1.SchemeGroupVersion.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithKind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ShootList&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shootList, client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">InNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;garden-my-project&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Limit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shootList.Items) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // project has at least one shoot</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // project doesn&#39;t have any shoots</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="gardener-s-client-collection-clientmaps" tabindex="-1">Gardener&#39;s Client Collection, ClientMaps <a class="header-anchor" href="#gardener-s-client-collection-clientmaps" aria-label="Permalink to &quot;Gardener&#39;s Client Collection, ClientMaps&quot;">​</a></h3><p>The Gardener codebase has a collection of clients (<a href="https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L149" target="_blank" rel="noreferrer"><code>kubernetes.Interface</code></a>), which can return all the above mentioned client types. Additionally, it contains helpers for rendering and applying helm charts (<code>ChartRender</code>, <code>ChartApplier</code>) and retrieving the API server&#39;s version (<code>Version</code>). Client sets are managed by so called <code>ClientMap</code>s, which are a form of registry for all client set for a given type of cluster, i.e., Garden, Seed and Shoot. ClientMaps manage the whole lifecycle of clients: they take care of creating them if they don&#39;t exist already, running their caches, refreshing their cached server version and invalidating them when they are no longer needed.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx   </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cm    </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clientmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClientMap</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;github.com/gardener/gardener/pkg/client/kubernetes/clientmap&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gardencorev1beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shoot</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cs, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, keys.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ForShoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shoot)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// kubernetes.Interface</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// client.Client</span></span></code></pre></div><p>The client collection mainly exist for historical reasons (there used to be a lot of code using the client-go style clients). However, Gardener is in the process of moving more towards controller-runtime and only using their clients, as they provide many benefits and are much easier to use. Also, <a href="https://github.com/gardener/gardener/issues/4251" target="_blank" rel="noreferrer">gardener/gardener#4251</a> aims at refactoring our controller and admission components to native controller-runtime components.</p><blockquote><p>⚠️ Please always prefer controller-runtime clients over other clients when writing new code or refactoring existing code.</p></blockquote><h2 id="cache-types-informers-listers-controller-runtime-caches" tabindex="-1">Cache Types: Informers, Listers, Controller-Runtime Caches <a class="header-anchor" href="#cache-types-informers-listers-controller-runtime-caches" aria-label="Permalink to &quot;Cache Types: Informers, Listers, Controller-Runtime Caches&quot;">​</a></h2><p>Similar to the different types of client(set)s, there are also different kinds of Kubernetes client caches. However, all of them are based on the same concept: <code>Informer</code>s. An <code>Informer</code> is a watch-based cache implementation, meaning it opens <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes" target="_blank" rel="noreferrer">watch connections</a> to the API server and continuously updates cached objects based on the received watch events (<code>ADDED</code>, <code>MODIFIED</code>, <code>DELETED</code>). <code>Informer</code>s offer to add indices to the cache for efficient object lookup (e.g., by name or labels) and to add <code>EventHandler</code>s for the watch events. The latter is used by controllers to fill queues with objects that should be reconciled on watch events.</p><p>Informers are used in and created via several higher-level constructs:</p><h3 id="sharedinformerfactories-listers" tabindex="-1">SharedInformerFactories, Listers <a class="header-anchor" href="#sharedinformerfactories-listers" aria-label="Permalink to &quot;SharedInformerFactories, Listers&quot;">​</a></h3><p>The generated clients (built-in as well as extended) feature a <code>SharedInformerFactory</code> for every API group, which can be used to create and retrieve <code>Informers</code> for all GroupVersionKinds. Similarly, it can be used to retrieve <code>Listers</code> that allow getting and listing objects from the <code>Informer</code>&#39;s cache. However, both of these constructs are only used for historical reasons, and we are in the process of migrating away from them in favor of cached controller-runtime clients (see <a href="https://github.com/gardener/gardener/issues/2414" target="_blank" rel="noreferrer">gardener/gardener#2414</a>, <a href="https://github.com/gardener/gardener/issues/2822" target="_blank" rel="noreferrer">gardener/gardener#2822</a>). Thus, they are described only briefly here.</p><p><em>Important characteristics of Listers:</em></p><ul><li>Objects read from Informers and Listers can always be slightly out-out-date (i.e., stale) because the client has to first observe changes to API objects via watch events (which can intermittently lag behind by a second or even more).</li><li>Thus, don&#39;t make any decisions based on data read from Listers if the consequences of deciding wrongfully based on stale state might be catastrophic (e.g. leaking infrastructure resources). In such cases, read directly from the API server via a client instead.</li><li>Objects retrieved from Informers or Listers are pointers to the cached objects, so they must not be modified without copying them first, otherwise the objects in the cache are also modified.</li></ul><h3 id="controller-runtime-caches" tabindex="-1">Controller-Runtime Caches <a class="header-anchor" href="#controller-runtime-caches" aria-label="Permalink to &quot;Controller-Runtime Caches&quot;">​</a></h3><p>controller-runtime features a cache implementation that can be used equivalently as their clients. In fact, it implements a subset of the <code>client.Client</code> interface containing the <code>Get</code> and <code>List</code> functions. Under the hood, a <code>cache.Cache</code> dynamically creates <code>Informers</code> (i.e., opens watches) for every object GroupVersionKind that is being retrieved from it.</p><p>Note that the underlying Informers of a controller-runtime cache (<code>cache.Cache</code>) and the ones of a <code>SharedInformerFactory</code> (client-go) are not related in any way. Both create <code>Informers</code> and watch objects on the API server individually. This means that if you read the same object from different cache implementations, you may receive different versions of the object because the watch connections of the individual Informers are not synced.</p><blockquote><p>⚠️ Because of this, controllers/reconcilers should get the object from the same cache in the reconcile loop, where the <code>EventHandler</code> was also added to set up the controller. For example, if a <code>SharedInformerFactory</code> is used for setting up the controller then read the object in the reconciler from the <code>Lister</code> instead of from a cached controller-runtime client.</p></blockquote><p>By default, the <code>client.Client</code> created by a controller-runtime <code>Manager</code> is a <code>DelegatingClient</code>. It delegates <code>Get</code> and <code>List</code> calls to a <code>Cache</code>, and all other calls to a client that talks directly to the API server. Exceptions are requests with <code>*unstructured.Unstructured</code> objects and object kinds that were configured to be excluded from the cache in the <code>DelegatingClient</code>.</p><blockquote><p>ℹ️ <code>kubernetes.Interface.Client()</code> returns a <code>DelegatingClient</code> that uses the cache returned from <code>kubernetes.Interface.Cache()</code> under the hood. This means that all <code>Client()</code> usages need to be ready for cached clients and should be able to cater with stale cache reads.</p></blockquote><p><em>Important characteristics of cached controller-runtime clients:</em></p><ul><li>Like for Listers, objects read from a controller-runtime cache can always be slightly out of date. Hence, don&#39;t base any important decisions on data read from the cache (see above).</li><li>In contrast to Listers, controller-runtime caches fill the passed in-memory object with the state of the object in the cache (i.e., they perform something like a &quot;deep copy into&quot;). This means that objects read from a controller-runtime cache can safely be modified without unintended side effects.</li><li>Reading from a controller-runtime cache or a cached controller-runtime client implicitly starts a watch for the given object kind under the hood. This has important consequences: <ul><li>Reading a given object kind from the cache for the first time can take up to a few seconds depending on size and amount of objects as well as API server latency. This is because the cache has to do a full list operation and wait for an initial watch sync before returning results.</li><li>⚠️ Controllers need appropriate RBAC permissions for the object kinds they retrieve via cached clients (i.e., <code>list</code> and <code>watch</code>).</li><li>⚠️ By default, watches started by a controller-runtime cache are cluster-scoped, meaning it watches and caches objects across all namespaces. Thus, be careful which objects to read from the cache as it might significantly increase the controller&#39;s memory footprint.</li></ul></li><li>There is no interaction with the cache on writing calls (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>), see below.</li></ul><p><strong>Uncached objects, filtered caches, <code>APIReader</code>s:</strong></p><p>In order to allow more granular control over which object kinds should be cached and which calls should bypass the cache, controller-runtime offers a few mechanisms to further tweak the client/cache behavior:</p><ul><li>When creating a <code>DelegatingClient</code>, certain object kinds can be configured to always be read directly from the API instead of from the cache. Note that this does not prevent starting a new Informer when retrieving them directly from the cache.</li><li>Watches can be restricted to a given (set of) namespace(s) by setting <code>cache.Options.Namespaces</code>.</li><li>Watches can be filtered (e.g., by label) per object kind by configuring <code>cache.Options.SelectorsByObject</code> on creation of the cache.</li><li>Retrieving metadata-only objects or lists from a cache results in a metadata-only watch/cache for that object kind.</li><li>The <code>APIReader</code> can be used to always talk directly to the API server for a given <code>Get</code> or <code>List</code> call (use with care and only as a last resort!).</li></ul><h3 id="to-cache-or-not-to-cache" tabindex="-1">To Cache or Not to Cache <a class="header-anchor" href="#to-cache-or-not-to-cache" aria-label="Permalink to &quot;To Cache or Not to Cache&quot;">​</a></h3><p>Although watch-based caches are an important factor for the immense scalability of Kubernetes, it definitely comes at a price (mainly in terms of memory consumption). Thus, developers need to be careful when introducing new API calls and caching new object kinds. Here are some general guidelines on choosing whether to read from a cache or not:</p><ul><li>Always try to use the cache wherever possible and make your controller able to tolerate stale reads. <ul><li>Leverage optimistic locking: use deterministic naming for objects you create (this is what the <code>Deployment</code> controller does [2]).</li><li>Leverage optimistic locking / concurrency control of the API server: send updates/patches with the last-known <code>resourceVersion</code> from the cache (see below). This will make the request fail, if there were concurrent updates to the object (conflict error), which indicates that we have operated on stale data and might have made wrong decisions. In this case, let the controller handle the error with exponential backoff. This will make the controller eventually consistent.</li><li>Track the actions you took, e.g., when creating objects with <code>generateName</code> (this is what the <code>ReplicaSet</code> controller does [3]). The actions can be tracked in memory and repeated if the expected watch events don&#39;t occur after a given amount of time.</li><li>Always try to write controllers with the assumption that data will only be eventually correct and can be slightly out of date (even if read directly from the API server!).</li><li>If there is already some other code that needs a cache (e.g., a controller watch), reuse it instead of doing extra direct reads.</li><li>Don&#39;t read an object again if you just sent a write request. Write requests (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>) don&#39;t interact with the cache. Hence, use the current state that the API server returned (filled into the passed in-memory object), which is basically a &quot;free direct read&quot; instead of reading the object again from a cache, because this will probably set back the object to an older <code>resourceVersion</code>.</li></ul></li><li>If you are concerned about the impact of the resulting cache, try to minimize that by using filtered or metadata-only watches.</li><li>If watching and caching an object type is not feasible, for example because there will be a lot of updates, and you are only interested in the object every ~5m, or because it will blow up the controllers memory footprint, fallback to a direct read. This can either be done by disabling caching the object type generally or doing a single request via an <code>APIReader</code>. In any case, please bear in mind that every direct API call results in a <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#the-resourceversion-parameter" target="_blank" rel="noreferrer">quorum read from etcd</a>, which can be costly in a heavily-utilized cluster and impose significant scalability limits. Thus, always try to minimize the impact of direct calls by filtering results by namespace or labels, limiting the number of results and/or using metadata-only calls.</li></ul><p>[2] The <code>Deployment</code> controller uses the pattern <code>&lt;deployment-name&gt;-&lt;podtemplate-hash&gt;</code> for naming <code>ReplicaSets</code>. This means, the name of a <code>ReplicaSet</code> it tries to create/update/delete at any given time is deterministically calculated based on the <code>Deployment</code> object. By this, it is insusceptible to stale reads from its <code>ReplicaSets</code> cache.</p><p>[3] In simple terms, the <code>ReplicaSet</code> controller tracks its <code>CREATE pod</code> actions as follows: when creating new <code>Pods</code>, it increases a counter of expected <code>ADDED</code> watch events for the corresponding <code>ReplicaSet</code>. As soon as such events arrive, it decreases the counter accordingly. It only creates new <code>Pods</code> for a given <code>ReplicaSet</code> once all expected events occurred (counter is back to zero) or a timeout has occurred. This way, it prevents creating more <code>Pods</code> than desired because of stale cache reads and makes the controller eventually consistent.</p><h2 id="conflicts-concurrency-control-and-optimistic-locking" tabindex="-1">Conflicts, Concurrency Control, and Optimistic Locking <a class="header-anchor" href="#conflicts-concurrency-control-and-optimistic-locking" aria-label="Permalink to &quot;Conflicts, Concurrency Control, and Optimistic Locking&quot;">​</a></h2><p>Every Kubernetes API object contains the <code>metadata.resourceVersion</code> field, which identifies an object&#39;s version in the backing data store, i.e., etcd. Every write to an object in etcd results in a newer <code>resourceVersion</code>. This field is mainly used for concurrency control on the API server in an optimistic locking fashion, but also for efficient resumption of interrupted watch connections.</p><p>Optimistic locking in the Kubernetes API sense means that when a client wants to update an API object, then it includes the object&#39;s <code>resourceVersion</code> in the request to indicate the object&#39;s version the modifications are based on. If the <code>resourceVersion</code> in etcd has not changed in the meantime, the update request is accepted by the API server and the updated object is written to etcd. If the <code>resourceVersion</code> sent by the client does not match the one of the object stored in etcd, there were concurrent modifications to the object. Consequently, the request is rejected with a conflict error (status code <code>409</code>, API reason <code>Conflict</code>), for example:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;kind&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;apiVersion&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;v1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;metadata&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {},</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Failure&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Operation cannot be fulfilled on configmaps </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">foo</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: the object has been modified; please apply your changes to the latest version and try again&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;reason&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Conflict&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;details&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;kind&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;configmaps&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">409</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This concurrency control is an important mechanism in Kubernetes as there are typically multiple clients acting on API objects at the same time (humans, different controllers, etc.). If a client receives a conflict error, it should read the object&#39;s latest version from the API server, make the modifications based on the newest changes, and retry the update. The reasoning behind this is that a client might choose to make different decisions based on the concurrent changes made by other actors compared to the outdated version that it operated on.</p><p><em>Important points about concurrency control and conflicts:</em></p><ul><li>The <code>resourceVersion</code> field carries a string value and clients must not assume numeric values (the type and structure of versions depend on the backing data store). This means clients may compare <code>resourceVersion</code> values to detect whether objects were changed. But they must not compare <code>resourceVersion</code>s to figure out which one is newer/older, i.e., no greater/less-than comparisons are allowed.</li><li>By default, update calls (e.g. via client-go and controller-runtime clients) use optimistic locking as the passed in-memory usually object contains the latest <code>resourceVersion</code> known to the controller, which is then also sent to the API server.</li><li>API servers can also choose to accept update calls without optimistic locking (i.e., without a <code>resourceVersion</code> in the object&#39;s metadata) for any given resource. However, sending update requests without optimistic locking is strongly discouraged, as doing so overwrites the entire object, discarding any concurrent changes made to it.</li><li>On the other side, patch requests can always be executed either with or without optimistic locking, by (not) including the <code>resourceVersion</code> in the patched object&#39;s metadata. Sending patch requests without optimistic locking might be safe and even desirable as a patch typically updates only a specific section of the object. However, there are also situations where patching without optimistic locking is not safe (see below).</li></ul><h3 id="don-t-retry-on-conflict" tabindex="-1">Don’t Retry on Conflict <a class="header-anchor" href="#don-t-retry-on-conflict" aria-label="Permalink to &quot;Don’t Retry on Conflict&quot;">​</a></h3><p>Similar to how a human would typically handle a conflict error, there are helper functions implementing <code>RetryOnConflict</code>-semantics, i.e., try an update call, then re-read the object if a conflict occurs, apply the modification again and retry the update. However, controllers should generally <em>not</em> use <code>RetryOnConflict</code>-semantics. Instead, controllers should abort their current reconciliation run and let the queue handle the conflict error with exponential backoff. The reasoning behind this is that a conflict error indicates that the controller has operated on stale data and might have made wrong decisions earlier on in the reconciliation. When using a helper function that implements <code>RetryOnConflict</code>-semantics, the controller doesn&#39;t check which fields were changed and doesn&#39;t revise its previous decisions accordingly. Instead, retrying on conflict basically just ignores any conflict error and blindly applies the modification.</p><p>To properly solve the conflict situation, controllers should immediately return with the error from the update call. This will cause retries with exponential backoff so that the cache has a chance to observe the latest changes to the object. In a later run, the controller will then make correct decisions based on the newest version of the object, not run into conflict errors, and will then be able to successfully reconcile the object. This way, the controller becomes eventually consistent.</p><p>The other way to solve the situation is to modify objects without optimistic locking in order to avoid running into a conflict in the first place (only if this is safe). This can be a preferable solution for controllers with long-running reconciliations (which is actually an anti-pattern but quite unavoidable in some of Gardener&#39;s controllers). Aborting the entire reconciliation run is rather undesirable in such cases, as it will add a lot of unnecessary waiting time for end users and overhead in terms of compute and network usage.</p><p>However, in any case, retrying on conflict is probably not the right option to solve the situation (there are some correct use cases for it, though, they are very rare). Hence, don&#39;t retry on conflict.</p><h3 id="to-lock-or-not-to-lock" tabindex="-1">To Lock or Not to Lock <a class="header-anchor" href="#to-lock-or-not-to-lock" aria-label="Permalink to &quot;To Lock or Not to Lock&quot;">​</a></h3><p>As explained before, conflicts are actually important and prevent clients from doing wrongful concurrent updates. This means that conflicts are not something we generally want to avoid or ignore. However, in many cases controllers are exclusive owners of the fields they want to update and thus it might be safe to run without optimistic locking.</p><p>For example, the gardenlet is the exclusive owner of the <code>spec</code> section of the Extension resources it creates on behalf of a Shoot (e.g., the <code>Infrastructure</code> resource for creating VPC). Meaning, it knows the exact desired state and no other actor is supposed to update the Infrastructure&#39;s <code>spec</code> fields. When the gardenlet now updates the Infrastructures <code>spec</code> section as part of the Shoot reconciliation, it can simply issue a <code>PATCH</code> request that only updates the <code>spec</code> and runs without optimistic locking. If another controller concurrently updated the object in the meantime (e.g., the <code>status</code> section), the <code>resourceVersion</code> got changed, which would cause a conflict error if running with optimistic locking. However, concurrent <code>status</code> updates would not change the gardenlet&#39;s mind on the desired <code>spec</code> of the Infrastructure resource as it is determined only by looking at the Shoot&#39;s specification. If the <code>spec</code> section was changed concurrently, it&#39;s still fine to overwrite it because the gardenlet should reconcile the <code>spec</code> back to its desired state.</p><p>Generally speaking, if a controller is the exclusive owner of a given set of fields and they are independent of concurrent changes to other fields in that object, it can patch these fields without optimistic locking. This might ignore concurrent changes to other fields or blindly overwrite changes to the same fields, but this is fine if the mentioned conditions apply. Obviously, this applies only to patch requests that modify only a specific set of fields but not to update requests that replace the entire object.</p><p>In such cases, it&#39;s even desirable to run without optimistic locking as it will be more performant and save retries. If certain requests are made with high frequency and have a good chance of causing conflicts, retries because of optimistic locking can cause a lot of additional network traffic in a large-scale Gardener installation.</p><h2 id="updates-patches-server-side-apply" tabindex="-1">Updates, Patches, Server-Side Apply <a class="header-anchor" href="#updates-patches-server-side-apply" aria-label="Permalink to &quot;Updates, Patches, Server-Side Apply&quot;">​</a></h2><p>There are different ways of modifying Kubernetes API objects. The following snippet demonstrates how to do a given modification with the most frequently used options using a controller-runtime client:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx   </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c     </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gardencorev1beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shoot</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// update</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoot.Spec.Kubernetes.Version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.26&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shoot)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// json merge patch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">patch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MergeFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoot.Spec.Kubernetes.Version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.26&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shoot, patch)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// strategic merge patch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">patch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrategicMergeFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoot.Spec.Kubernetes.Version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1.26&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, shoot, patch)</span></span></code></pre></div><p><em>Important characteristics of the shown request types:</em></p><ul><li>Update requests always send the entire object to the API server and update all fields accordingly. By default, optimistic locking is used (<code>resourceVersion</code> is included).</li><li>Both patch types run without optimistic locking by default. However, it can be enabled explicitly if needed:<div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// json merge patch + optimistic locking</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">patch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MergeFromWithOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MergeFromWithOptimisticLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// strategic merge patch + optimistic locking</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">patch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrategicMergeFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MergeFromWithOptimisticLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span></code></pre></div></li><li>Patch requests only contain the changes made to the in-memory object between the copy passed to <code>client.*MergeFrom</code> and the object passed to <code>Client.Patch()</code>. The diff is calculated on the client-side based on the in-memory objects only. This means that if in the meantime some fields were changed on the API server to a different value than the one on the client-side, the fields will not be changed back as long as they are not changed on the client-side as well (there will be no diff in memory).</li><li>Thus, if you want to ensure a given state using patch requests, always read the object first before patching it, as there will be no diff otherwise, meaning the patch will be empty. For more information, see <a href="https://github.com/gardener/gardener/pull/4057" target="_blank" rel="noreferrer">gardener/gardener#4057</a> and the comments in <a href="https://github.com/gardener/gardener/pull/4027" target="_blank" rel="noreferrer">gardener/gardener#4027</a>.</li><li>Also, always send updates and patch requests even if your controller hasn&#39;t made any changes to the current state on the API server. I.e., don&#39;t make any optimization for preventing empty patches or no-op updates. There might be mutating webhooks in the system that will modify the object and that rely on update/patch requests being sent (even if they are no-op). Gardener&#39;s extension concept makes heavy use of mutating webhooks, so it&#39;s important to keep this in mind.</li><li>JSON merge patches always replace lists as a whole and don&#39;t merge them. Keep this in mind when operating on lists with merge patch requests. If the controller is the exclusive owner of the entire list, it&#39;s safe to run without optimistic locking. Though, if you want to prevent overwriting concurrent changes to the list or its items made by other actors (e.g., additions/removals to the <code>metadata.finalizers</code> list), enable optimistic locking.</li><li>Strategic merge patches are able to make more granular modifications to lists and their elements without replacing the entire list. It uses Golang struct tags of the API types to determine which and how lists should be merged. See <a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/" target="_blank" rel="noreferrer">Update API Objects in Place Using kubectl patch</a> or the <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md" target="_blank" rel="noreferrer">strategic merge patch documentation</a> for more in-depth explanations and comparison with JSON merge patches. With this, controllers <em>might</em> be able to issue patch requests for individual list items without optimistic locking, even if they are not exclusive owners of the entire list. Remember to check the <code>patchStrategy</code> and <code>patchMergeKey</code> struct tags of the fields you want to modify before blindly adding patch requests without optimistic locking.</li><li>Strategic merge patches are only supported by built-in Kubernetes resources and custom resources served by Extension API servers. Strategic merge patches are not supported by custom resources defined by <code>CustomResourceDefinition</code>s (see <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#advanced-features-and-flexibility" target="_blank" rel="noreferrer">this comparison</a>). In that case, fallback to JSON merge patches.</li><li><a href="https://kubernetes.io/docs/reference/using-api/server-side-apply/" target="_blank" rel="noreferrer">Server-side Apply</a> is yet another mechanism to modify API objects, which is supported by all API resources (in newer Kubernetes versions). However, it has a few problems and more caveats preventing us from using it in Gardener at the time of writing. See <a href="https://github.com/gardener/gardener/issues/4122" target="_blank" rel="noreferrer">gardener/gardener#4122</a> for more details.</li></ul><blockquote><p>Generally speaking, patches are often the better option compared to update requests because they can save network traffic, encoding/decoding effort, and avoid conflicts under the presented conditions. If choosing a patch type, consider which type is supported by the resource you&#39;re modifying and what will happen in case of a conflict. Consider whether your modification is safe to run without optimistic locking. However, there is no simple rule of thumb on which patch type to choose.</p></blockquote><h2 id="on-helper-functions" tabindex="-1">On Helper Functions <a class="header-anchor" href="#on-helper-functions" aria-label="Permalink to &quot;On Helper Functions&quot;">​</a></h2><p>Here is a note on some helper functions, that should be avoided and why:</p><p><code>controllerutil.CreateOrUpdate</code> does a basic get, mutate and create or update call chain, which is often used in controllers. We should avoid using this helper function in Gardener, because it is likely to cause conflicts for cached clients and doesn&#39;t send no-op requests if nothing was changed, which can cause problems because of the heavy use of webhooks in Gardener extensions (see above). That&#39;s why usage of this function was completely replaced in <a href="https://github.com/gardener/gardener/pull/4227" target="_blank" rel="noreferrer">gardener/gardener#4227</a> and similar PRs.</p><p><code>controllerutil.CreateOrPatch</code> is similar to <code>CreateOrUpdate</code> but does a patch request instead of an update request. It has the same drawback as <code>CreateOrUpdate</code> regarding no-op updates. Also, controllers can&#39;t use optimistic locking or strategic merge patches when using <code>CreateOrPatch</code>. Another reason for avoiding use of this function is that it also implicitly patches the status section if it was changed, which is confusing for others reading the code. To accomplish this, the func does some back and forth conversion, comparison and checks, which are unnecessary in most of our cases and simply wasted CPU cycles and complexity we want to avoid.</p><p>There were some <code>Try{Update,UpdateStatus,Patch,PatchStatus}</code> helper functions in Gardener that were already removed by <a href="https://github.com/gardener/gardener/pull/4378" target="_blank" rel="noreferrer">gardener/gardener#4378</a> but are still used in some extension code at the time of writing. The reason for eliminating these functions is that they implement <code>RetryOnConflict</code>-semantics. Meaning, they first get the object, mutate it, then try to update and retry if a conflict error occurs. As explained above, retrying on conflict is a controller anti-pattern and should be avoided in almost every situation. The other problem with these functions is that they read the object first from the API server (always do a direct call), although in most cases we already have a recent version of the object at hand. So, using this function generally does unnecessary API calls and therefore causes unwanted compute and network load.</p><p>For the reasons explained above, there are similar helper functions that accomplish similar things but address the mentioned drawbacks: <code>controllerutils.{GetAndCreateOrMergePatch,GetAndCreateOrStrategicMergePatch}</code>. These can be safely used as replacements for the aforementioned helper funcs. If they are not fitting for your use case, for example because you need to use optimistic locking, just do the appropriate calls in the controller directly.</p><h2 id="related-links" tabindex="-1">Related Links <a class="header-anchor" href="#related-links" aria-label="Permalink to &quot;Related Links&quot;">​</a></h2><ul><li><a href="https://www.youtube.com/watch?v=RPsUo925PUA&amp;t=40s" target="_blank" rel="noreferrer">Kubernetes Client usage in Gardener</a> (Community Meeting talk, 2020-06-26)</li></ul><p>These resources are only partially related to the topics covered in this doc, but might still be interesting for developer seeking a deeper understanding of Kubernetes API machinery, architecture and foundational concepts.</p><ul><li><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noreferrer">API Conventions</a></li><li><a href="https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/resource-management.md" target="_blank" rel="noreferrer">The Kubernetes Resource Model</a></li></ul>`,88)]))}const u=t(n,[["render",o]]);export{k as __pageData,u as default};
