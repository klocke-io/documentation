import{_ as o,c as d,o as n,a2 as t}from"./chunks/framework.B8WFj13S.js";const m=JSON.parse('{"title":"Readiness of Shoot Worker Nodes","description":"Implementation in Gardener for readiness of Shoot worker Nodes. How to mark components as node-critical","frontmatter":{"aliases":["/docs/gardener/node-readiness/"],"description":"Implementation in Gardener for readiness of Shoot worker Nodes. How to mark components as node-critical","github_repo":"https://github.com/gardener/gardener","github_subdir":"docs/usage/advanced","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/gardener/advanced/node-readiness.md","to":"node-readiness.md"},"persona":"Users","title":"Readiness of Shoot Worker Nodes","prev":false,"next":false},"headers":[],"relativePath":"docs/gardener/advanced/node-readiness/index.md","filePath":"docs/gardener/advanced/node-readiness.md","lastUpdated":null}'),r={name:"docs/gardener/advanced/node-readiness/index.md"};function a(i,e,c,s,l,h){return n(),d("div",null,e[0]||(e[0]=[t('<h1 id="readiness-of-shoot-worker-nodes" tabindex="-1">Readiness of Shoot Worker Nodes <a class="header-anchor" href="#readiness-of-shoot-worker-nodes" aria-label="Permalink to &quot;Readiness of Shoot Worker Nodes&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>When registering new <code>Nodes</code>, kubelet adds the <code>node.kubernetes.io/not-ready</code> taint to prevent scheduling workload Pods to the <code>Node</code> until the <code>Ready</code> condition gets <code>True</code>. However, the kubelet does not consider the readiness of node-critical Pods. Hence, the <code>Ready</code> condition might get <code>True</code> and the <code>node.kubernetes.io/not-ready</code> taint might get removed, for example, before the CNI daemon Pod (e.g., <code>calico-node</code>) has successfully placed the CNI binaries on the machine.</p><p>This problem has been discussed extensively in kubernetes, e.g., in <a href="https://github.com/kubernetes/kubernetes/issues/75890" target="_blank" rel="noreferrer">kubernetes/kubernetes#75890</a>. However, several proposals have been rejected because the problem can be solved by using the <code>--register-with-taints</code> kubelet flag and dedicated controllers (<a href="https://github.com/kubernetes/enhancements/pull/1003#issuecomment-619087019" target="_blank" rel="noreferrer">ref</a>).</p><h2 id="implementation-in-gardener" tabindex="-1">Implementation in Gardener <a class="header-anchor" href="#implementation-in-gardener" aria-label="Permalink to &quot;Implementation in Gardener&quot;">​</a></h2><p>Gardener makes sure that workload Pods are only scheduled to <code>Nodes</code> where all node-critical components required for running workload Pods are ready. For this, Gardener follows the proposed solution by the Kubernetes community and registers new <code>Node</code> objects with the <code>node.gardener.cloud/critical-components-not-ready</code> taint (effect <code>NoSchedule</code>). gardener-resource-manager&#39;s <a href="/documentation/pr-preview/pr-2/docs/gardener/concepts/resource-manager/#node-controller"><code>Node</code> controller</a> reacts on newly created <code>Node</code> objects that have this taint. The controller removes the taint once all node-critical Pods are ready (determined by checking the Pods&#39; <code>Ready</code> conditions).</p><p>The <code>Node</code> controller considers all <code>DaemonSets</code> and <code>Pods</code> as node-critical which run in the <code>kube-system</code> namespace and are labeled with <code>node.gardener.cloud/critical-component=true</code>. If there are <code>DaemonSets</code> that contain the <code>node.gardener.cloud/critical-component=true</code> label in their metadata and in their Pod template, the <code>Node</code> controller waits for corresponding daemon Pods to be scheduled and to get ready before removing the taint.</p><p>Additionally, the <code>Node</code> controller checks for the readiness of <code>csi-driver-node</code> components if a respective Pod indicates that it uses such a driver. This is achieved through a well-defined annotation prefix (<code>node.gardener.cloud/wait-for-csi-node-</code>). For example, the <code>csi-driver-node</code> Pod for Openstack Cinder is annotated with <code>node.gardener.cloud/wait-for-csi-node-cinder=cinder.csi.openstack.org</code>. A key prefix is used instead of a &quot;regular&quot; annotation to allow for multiple CSI drivers being registered by one <code>csi-driver-node</code> Pod. The annotation key&#39;s suffix can be chosen arbitrarily (in this case <code>cinder</code>) and the annotation value needs to match the actual driver name as specified in the <code>CSINode</code> object. The <code>Node</code> controller will verify that the used driver is properly registered in this object before removing the <code>node.gardener.cloud/critical-components-not-ready</code> taint. Note that the <code>csi-driver-node</code> Pod still needs to be labelled and tolerate the taint as described above to be considered in this additional check.</p><h2 id="marking-node-critical-components" tabindex="-1">Marking Node-Critical Components <a class="header-anchor" href="#marking-node-critical-components" aria-label="Permalink to &quot;Marking Node-Critical Components&quot;">​</a></h2><p>To make use of this feature, node-critical DaemonSets and Pods need to:</p><ul><li>Tolerate the <code>node.gardener.cloud/critical-components-not-ready</code> <code>NoSchedule</code> taint.</li><li>Be labelled with <code>node.gardener.cloud/critical-component=true</code>.</li><li>Be placed in the <code>kube-system</code> namespace.</li></ul><p><code>csi-driver-node</code> Pods additionally need to:</p><ul><li>Be annotated with <code>node.gardener.cloud/wait-for-csi-node-&lt;name&gt;=&lt;full-driver-name&gt;</code>. It&#39;s required that these Pods fulfill the above criteria (label and toleration) as well.</li></ul><p>Gardener already marks components like kube-proxy, apiserver-proxy and node-local-dns as node-critical. Provider extensions mark components like csi-driver-node as node-critical and add the <code>wait-for-csi-node</code> annotation. Network extensions mark components responsible for setting up CNI on worker Nodes (e.g., <code>calico-node</code>) as node-critical. If shoot owners manage any additional node-critical components, they can make use of this feature as well.</p>',14)]))}const p=o(r,[["render",a]]);export{m as __pageData,p as default};
