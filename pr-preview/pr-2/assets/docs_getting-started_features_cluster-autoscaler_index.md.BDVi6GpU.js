import{_ as t,c as a,o as r,a2 as o}from"./chunks/framework.B8WFj13S.js";const s="/documentation/pr-preview/pr-2/assets/additional-nodes.O7uG66Pq.gif",i="/documentation/pr-preview/pr-2/assets/priority-scaling.D2BVg9Q_.gif",g=JSON.parse('{"title":"Cluster Autoscaler","description":"","frontmatter":{"github_repo":"https://github.com/gardener/documentation","github_subdir":"website/documentation/getting-started/features","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/getting-started/features/cluster-autoscaler.md","to":"cluster-autoscaler.md"},"title":"Cluster Autoscaler","weight":7,"prev":false,"next":false},"headers":[],"relativePath":"docs/getting-started/features/cluster-autoscaler/index.md","filePath":"docs/getting-started/features/cluster-autoscaler.md","lastUpdated":null}'),n={name:"docs/getting-started/features/cluster-autoscaler/index.md"};function l(c,e,d,u,h,p){return r(),a("div",null,e[0]||(e[0]=[o('<h1 id="cluster-autoscaler" tabindex="-1">Cluster Autoscaler <a class="header-anchor" href="#cluster-autoscaler" aria-label="Permalink to &quot;Cluster Autoscaler&quot;">​</a></h1><h2 id="obtaining-aditional-nodes" tabindex="-1">Obtaining Aditional Nodes <a class="header-anchor" href="#obtaining-aditional-nodes" aria-label="Permalink to &quot;Obtaining Aditional Nodes&quot;">​</a></h2><p><img src="'+s+'" alt="additional-nodes"></p><p>The scheduler will assign pods to nodes, as long as they have capacity (CPU, memory, Pod limit, # attachable disks, ...). But what happens when all nodes are fully utilized and the scheduler does not find any suitable target?</p><p><strong>Option 1:</strong> Evict other pods based on priority. However, this has the downside that other workloads with lower priority might become unschedulable.</p><p><strong>Option 2:</strong> Add more nodes. There is an upstream Cluster Autoscaler project that does exactly this. It simulates the scheduling and reacts to pods not being schedulable events. Gardener has forked it to make it work with machine-controller-manager abstraction of how node (groups) are defined in Gardener. The cluster autoscaler respects the limits (min / max) of any worker pool in a shoot&#39;s spec. It can also scale down nodes based on utilization thresholds. For more details, see the <a href="https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md" target="_blank" rel="noreferrer">autoscaler documentation</a>.</p><h2 id="scaling-by-priority" tabindex="-1">Scaling by Priority <a class="header-anchor" href="#scaling-by-priority" aria-label="Permalink to &quot;Scaling by Priority&quot;">​</a></h2><p><img src="'+i+'" alt="priority-scaling"></p><p>For clusters with more than one node pool, the cluster autoscaler has to decide which group to scale up. By default, it randomly picks from the available / applicable. However, this behavior is customizable by the use of so-called expanders.</p><p>This section will focus on the priority based expander.</p><p>Each worker pool gets a priority and the cluster autoscaler will scale up the one with the highest priority until it reaches its limit.</p><p>To get more information on the current status of the autoscaler, you can check a &quot;status&quot; configmap in the <code>kube-system</code> namespace with the following command:</p><p><code>kubectl get cm -n kube-system cluster-autoscaler-status -oyaml</code></p><p>To obtain information about the decision making, you can check the logs of the cluster-autoscaler pod by using the shoot&#39;s monitoring stack.</p><p>For more information, see the <a href="https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#what-are-expanders" target="_blank" rel="noreferrer">cluster-autoscaler FAQ</a> and the <a href="https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/expander/priority/readme.md" target="_blank" rel="noreferrer">Priority based expander for cluster-autoscaler</a> topic.</p>',15)]))}const b=t(n,[["render",l]]);export{g as __pageData,b as default};
