import{_ as t,c as a,o,a2 as r}from"./chunks/framework.Bfq10Vlj.js";const s="/assets/webterminals-1.A4iwAOwI.png",m=JSON.parse('{"title":"Webterminals","description":"","frontmatter":{"github_repo":"https://github.com/gardener/dashboard","github_subdir":"docs/operations","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/dashboard/webterminals.md","to":"webterminals.md"},"persona":"Operators","title":"Webterminals","prev":false,"next":false},"headers":[],"relativePath":"docs/dashboard/webterminals/index.md","filePath":"docs/dashboard/webterminals.md","lastUpdated":null}'),n={name:"docs/dashboard/webterminals/index.md"};function i(l,e,d,h,c,u){return o(),a("div",null,e[0]||(e[0]=[r('<h1 id="webterminals" tabindex="-1">Webterminals <a class="header-anchor" href="#webterminals" aria-label="Permalink to &quot;Webterminals&quot;">​</a></h1><img width="180" alt="gardener-terminal-ascii" src="https://user-images.githubusercontent.com/5526658/66032047-ecfacc80-e504-11e9-9864-57d4f0bbaf5d.png"><h2 id="architecture-overview" tabindex="-1">Architecture Overview <a class="header-anchor" href="#architecture-overview" aria-label="Permalink to &quot;Architecture Overview&quot;">​</a></h2><img src="'+s+`"><h2 id="motivation" tabindex="-1">Motivation <a class="header-anchor" href="#motivation" aria-label="Permalink to &quot;Motivation&quot;">​</a></h2><p>We want to give garden operators and &quot;regular&quot; users of the Gardener dashboard an easy way to have a preconfigured shell directly in the browser.</p><p>This has several advantages:</p><ul><li>no need to set up any tools locally</li><li>no need to download / store kubeconfigs locally</li><li>Each terminal session will have its own &quot;access&quot; service account created. This makes it easier to see &quot;who&quot; did &quot;what&quot; when using the web terminals.</li><li>The &quot;access&quot; service account is deleted when the terminal session expires</li><li>Easy &quot;privileged&quot; access to a node (privileged container, hostPID, and hostNetwork enabled, mounted host root fs) in case of troubleshooting node. If allowed by PSP.</li></ul><h2 id="how-it-s-done-tl-dr" tabindex="-1">How it&#39;s done - TL;DR <a class="header-anchor" href="#how-it-s-done-tl-dr" aria-label="Permalink to &quot;How it&#39;s done - TL;DR&quot;">​</a></h2><p>On the host cluster, we schedule a pod to which the dashboard frontend client attaches to (similar to <code>kubectl attach</code>). Usually the <a href="https://github.com/gardener/ops-toolbelt/" target="_blank" rel="noreferrer"><code>ops-toolbelt</code></a> image is used, containing all relevant tools like <code>kubectl</code>. The Pod has a kubeconfig secret mounted with the necessary privileges for the target cluster - usually <code>cluster-admin</code>.</p><h2 id="target-types" tabindex="-1">Target types <a class="header-anchor" href="#target-types" aria-label="Permalink to &quot;Target types&quot;">​</a></h2><p>There are currently three targets, where a user can open a terminal session to:</p><ul><li>The (virtual) garden cluster - Currently operator only</li><li>The shoot cluster</li><li>The control plane of the shoot cluster - operator only</li></ul><h2 id="host" tabindex="-1">Host <a class="header-anchor" href="#host" aria-label="Permalink to &quot;Host&quot;">​</a></h2><p>There are different factors on where the host cluster (and namespace) is chosen by the dashboard:</p><ul><li>Depending on, the selected target and the role of the user (operator or &quot;regular&quot; user) the host is chosen.</li><li>For performance / low latency reasons, we want to place the &quot;terminal&quot; pods as near as possible to the target kube-apiserver.</li></ul><p>For example, the user wants to have a terminal for a shoot cluster. The kube-apiserver of the shoot is running in the seed-shoot-ns on the seed.</p><ul><li>If the user is an operator, we place the &quot;terminal&quot; pod directly in the seed-shoot-ns on the seed.</li><li>However, if the user is a &quot;regular&quot; user, we don’t want to have &quot;untrusted&quot; workload scheduled on the seeds, that&#39;s why the &quot;terminal&quot; pod is scheduled on the shoot itself, in a temporary namespace that is deleted afterwards.</li></ul><h2 id="lifecycle-of-a-web-terminal-session" tabindex="-1">Lifecycle of a Web Terminal Session <a class="header-anchor" href="#lifecycle-of-a-web-terminal-session" aria-label="Permalink to &quot;Lifecycle of a Web Terminal Session&quot;">​</a></h2><h3 id="_1-browser-dashboard-frontend-open-terminal" tabindex="-1">1. Browser / Dashboard Frontend - Open Terminal <a class="header-anchor" href="#_1-browser-dashboard-frontend-open-terminal" aria-label="Permalink to &quot;1. Browser / Dashboard Frontend - Open Terminal&quot;">​</a></h3><p>User chooses the target and clicks in the browser on <code>Open terminal</code> button. A POST request is made to the dashboard backend to request a new terminal session.</p><h3 id="_2-dashboard-backend-create-terminal-resource" tabindex="-1">2. Dashboard Backend - Create Terminal Resource <a class="header-anchor" href="#_2-dashboard-backend-create-terminal-resource" aria-label="Permalink to &quot;2. Dashboard Backend - Create Terminal Resource&quot;">​</a></h3><p>According to the privileges of the user (operator / enduser) and the selected target, the dashboard backend creates a <code>terminal</code> resource <strong>on behalf of the user</strong> in the (virtual) garden and responds with a handle to the terminal session.</p><h3 id="_3-browser-dashboard-frontend" tabindex="-1">3. Browser / Dashboard Frontend <a class="header-anchor" href="#_3-browser-dashboard-frontend" aria-label="Permalink to &quot;3. Browser / Dashboard Frontend&quot;">​</a></h3><p>The frontend makes another POST request to the dashboard backend to fetch the terminal session. The Backend waits until the <code>terminal</code> resource is in a &quot;ready&quot; state (timeout 10s) before sending a response to the frontend. More to that later.</p><h3 id="_4-terminal-resource" tabindex="-1">4. Terminal Resource <a class="header-anchor" href="#_4-terminal-resource" aria-label="Permalink to &quot;4. Terminal Resource&quot;">​</a></h3><p>The <code>terminal</code> resource, among other things, holds the information of the desired host and target cluster. The credentials to these clusters are declared as references (<code>shootRef</code>, <code>serviceAccountRef</code>). The <code>terminal</code> resource itself doesn’t contain sensitive information.</p><h3 id="_5-admission" tabindex="-1">5. Admission <a class="header-anchor" href="#_5-admission" aria-label="Permalink to &quot;5. Admission&quot;">​</a></h3><p>A validating webhook is in place to ensure that the user, that created the <code>terminal</code> resource, has the <strong>permission to read the referenced credentials</strong>. There is also a mutating webhook in place. Both admission configurations have <strong><code>failurePolicy: Fail</code></strong>.</p><h3 id="_6-terminal-controller-manager-apply-resources-on-host-target-cluster" tabindex="-1">6. Terminal-Controller-Manager - Apply Resources on Host &amp; Target Cluster <a class="header-anchor" href="#_6-terminal-controller-manager-apply-resources-on-host-target-cluster" aria-label="Permalink to &quot;6. Terminal-Controller-Manager - Apply Resources on Host &amp; Target Cluster&quot;">​</a></h3><p><em>Sidenote: The terminal-controller-manager has no knowledge about the gardener, its shoots, and seeds. In that sense it can be considered as independent from the gardener.</em></p><p>The <a href="https://github.com/gardener/terminal-controller-manager" target="_blank" rel="noreferrer">terminal-controller-manager</a> watches <code>terminal</code> resources and ensures the desired state on the host and target cluster. The terminal-controller-manager needs the permission to read all secrets / service accounts in the virtual garden. As additional safety net, the <strong>terminal-controller-manager</strong> ensures that the <code>terminal</code> resource was not created before the admission configurations were created.</p><p>The terminal-controller-manager then creates the necessary resources in the host and target cluster.</p><ul><li>Target Cluster: <ul><li>&quot;Access&quot; service account + (cluster)rolebinding usually to <code>cluster-admin</code> cluster role <ul><li>used from within the &quot;terminal&quot; pod</li></ul></li></ul></li><li>Host Cluster: <ul><li>&quot;Attach&quot; service Account + rolebinding to &quot;attach&quot; cluster role (privilege to attach and get pod) <ul><li>will be used by the browser to attach to the pod</li></ul></li><li>Kubeconfig secret, containing the &quot;access&quot; token from the target cluster</li><li>The &quot;terminal&quot; pod itself, having the kubeconfig secret mounted</li></ul></li></ul><h3 id="_7-dashboard-backend-responds-to-frontend" tabindex="-1">7. Dashboard Backend - Responds to Frontend <a class="header-anchor" href="#_7-dashboard-backend-responds-to-frontend" aria-label="Permalink to &quot;7. Dashboard Backend - Responds to Frontend&quot;">​</a></h3><p>As mentioned in step 3, the dashboard backend waits until the <code>terminal</code> resource is &quot;ready&quot;. It then reads the &quot;attach&quot; token from the host cluster <strong>on behalf of the user</strong>. It responds with:</p><ul><li>attach token</li><li>hostname of the host cluster&#39;s api server</li><li>name of the pod and namespace</li></ul><h3 id="_8-browser-dashboard-frontend-attach-to-pod" tabindex="-1">8. Browser / Dashboard Frontend - Attach to Pod <a class="header-anchor" href="#_8-browser-dashboard-frontend-attach-to-pod" aria-label="Permalink to &quot;8. Browser / Dashboard Frontend - Attach to Pod&quot;">​</a></h3><p>Dashboard frontend attaches to the pod located on the host cluster by opening a WebSocket connection using the provided parameter and credentials. As long as the terminal window is open, the dashboard regularly annotates the <code>terminal</code> resource (heartbeat) to keep it alive.</p><h3 id="_9-terminal-controller-manager-cleanup" tabindex="-1">9. Terminal-Controller-Manager - Cleanup <a class="header-anchor" href="#_9-terminal-controller-manager-cleanup" aria-label="Permalink to &quot;9. Terminal-Controller-Manager - Cleanup&quot;">​</a></h3><p>When there is no heartbeat on the <code>terminal</code> resource for a certain amount of time (default is <code>5m</code>) the created resources in the host and target cluster are cleaned up again and the <code>terminal</code> resource will be deleted.</p><h2 id="browser-trusted-certificates-for-kube-apiservers" tabindex="-1">Browser Trusted Certificates for Kube-Apiservers <a class="header-anchor" href="#browser-trusted-certificates-for-kube-apiservers" aria-label="Permalink to &quot;Browser Trusted Certificates for Kube-Apiservers&quot;">​</a></h2><p>When the dashboard frontend opens a secure WebSocket connection to the kube-apiserver, the certificate presented by the kube-apiserver must be browser trusted. Otherwise, the connection can&#39;t be established due to browser policy. Most kube-apiservers have self-signed certificates from a custom Root CA.</p><p>The Gardener project now handles the responsibility of exposing the kube-apiservers with browser trusted certificates for <code>Seed</code>s (gardener/gardener#7764) and <code>Shoot</code>s (gardener/gardener#7712). For this to work, a <code>Secret</code> must exist in the <code>garden</code> namespace of the <code>Seed</code> cluster. This <code>Secret</code> should have a label <code>gardener.cloud/role=controlplane-cert</code>. The Secret is expected to contain the wildcard certificate for <code>Seed</code>s ingress domain.</p><h2 id="allowlist-for-hosts" tabindex="-1">Allowlist for Hosts <a class="header-anchor" href="#allowlist-for-hosts" aria-label="Permalink to &quot;Allowlist for Hosts&quot;">​</a></h2><h3 id="motivation-1" tabindex="-1">Motivation <a class="header-anchor" href="#motivation-1" aria-label="Permalink to &quot;Motivation&quot;">​</a></h3><p>When a user starts a terminal session, the dashboard frontend establishes a secure WebSocket connection to the corresponding kube-apiserver. This connection is controlled by the <code>connectSrc</code> directive of the content security policy, which governs the hosts that the browser can connect to.</p><p>By default, the <code>connectSrc</code> directive only permits connections to the same host. However, to enable the webterminal feature to function properly, connections to additional trusted hosts are required. This is where the <code>allowedHostSourceList</code> configuration becomes relevant. It directly impacts the <code>connectSrc</code> directive by specifying the hostnames that the browser is allowed to connect to during a terminal session. By defining this list, you can extend the range of terminal connections to include the necessary trusted hosts, while still preventing any unauthorized or potentially harmful connections.</p><h3 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h3><p>The <code>allowedHostSourceList</code> can be configured within the <code>global.terminal</code> section of the <code>gardener-dashboard</code> Helm <code>values.yaml</code> file. The list should consist of permitted hostnames (without the scheme) for terminal connections.</p><p>It is important to consider that the usage of wildcards follows the rules defined by the content security policy.</p><p>Here is an example of how to configure the <code>allowedHostSourceList</code>:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  terminal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    allowedHostSourceList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*.seed.example.com&quot;</span></span></code></pre></div><p>In this example, any host under the seed.example.com domain is allowed for terminal connections.</p>`,54)]))}const b=t(n,[["render",i]]);export{m as __pageData,b as default};
