import{_ as t,c as i,o as a,a2 as s}from"./chunks/framework.B8WFj13S.js";const g=JSON.parse('{"title":"Oci Registries","description":"","frontmatter":{"github_repo":"https://github.com/gardener/gardener-extension-shoot-lakom-service","github_subdir":"docs","params":{"github_branch":"main"},"path_base_for_github_subdir":{"from":"content/docs/extensions/others/gardener-extension-shoot-lakom-service/oci_registries.md","to":"oci_registries.md"},"title":"Oci Registries","prev":false,"next":false},"headers":[],"relativePath":"docs/extensions/others/gardener-extension-shoot-lakom-service/oci_registries/index.md","filePath":"docs/extensions/others/gardener-extension-shoot-lakom-service/oci_registries.md","lastUpdated":null}'),n={name:"docs/extensions/others/gardener-extension-shoot-lakom-service/oci_registries/index.md"};function o(r,e,h,l,d,c){return a(),i("div",null,e[0]||(e[0]=[s(`<h1 id="oci-registries" tabindex="-1">OCI Registries <a class="header-anchor" href="#oci-registries" aria-label="Permalink to &quot;OCI Registries&quot;">​</a></h1><p>This document aims to introduce the reader to the general architecture of OCI Registries, their history and jargon that might be encountered.</p><h2 id="history-of-container-registries" tabindex="-1">History of Container Registries <a class="header-anchor" href="#history-of-container-registries" aria-label="Permalink to &quot;History of Container Registries&quot;">​</a></h2><p>Most readers might be familiar with the container registry that was introduced by Docker. It aims to provide a way for developers to store and distribute container images that can be used for running applications in containers.</p><p>In the beginning, the registry was meant to only host images in a way that the different layers of the image could be downloaded in parallel, while being assembled on the client side.</p><p>In June 2015, multiple companies agreed to standardize the container image format, including its distribution and runtime. This was the birth of the Open Container Initiative (OCI).</p><h2 id="understanding-oci-registries" tabindex="-1">Understanding OCI Registries <a class="header-anchor" href="#understanding-oci-registries" aria-label="Permalink to &quot;Understanding OCI Registries&quot;">​</a></h2><p>The most important document that pertains to OCI Registries in the case of Lakom is the <a href="https://github.com/opencontainers/distribution-spec/blob/main/spec.md" target="_blank" rel="noreferrer">OCI distribution spec</a>. It outlines the way that artifacts shall be stored and fetched from a registry that adheres to the OCI standard.</p><p>OCI Registries are meant to store <em>content</em>. While in the beginning the main problem that they were trying to solve was image storage, during the evolution of the image registry concept, a decision was made to make it more general for storage of any form of objects, sometimes called <em>artifacts</em>.</p><p>An artifact is an abstract idea of multiple components that together describe how an object is built along with storing metadata about the object.</p><p>To implement this, every OCI registry has to expose an API for creating 3 types of objects:</p><ul><li>Blobs</li><li>Manifests</li><li>Tags</li></ul><h3 id="blobs" tabindex="-1">Blobs <a class="header-anchor" href="#blobs" aria-label="Permalink to &quot;Blobs&quot;">​</a></h3><p>A blob is just a set of bytes. Nothing more. The important part about blobs is that they are <em>content addressable</em>. <a href="https://en.wikipedia.org/wiki/Content-addressable_storage" target="_blank" rel="noreferrer">Content Addressable Storage (CAS)</a> is a method of storing data in such a way that the address of the data is derived from the data itself. This means that if you store the same blob twice, it will be stored only once, and the address of the blob will be the same. This is achieved by using the <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noreferrer">digest</a> of the blob as the address.</p><p>This is the actual mechanism for allowing images to be optimal in terms of storage. Since most images begin by depending on the same base image, this means that it can be stored only once and referenced by multiple images.</p><h3 id="manifests" tabindex="-1">Manifests <a class="header-anchor" href="#manifests" aria-label="Permalink to &quot;Manifests&quot;">​</a></h3><p>A manifest is just a JSON document. It is stored separately from the blobs. But similarly to the blobs, it is also content addressable. The manifest gets formatted to a canonical form and then hashed. The hash becomes the address of the manifest.</p><p>Where manifests become powerful is when they are used to reference to other manifests or blobs. These references are called <a href="https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md" target="_blank" rel="noreferrer">OCI Content Descriptors</a>. For example, the Image Manifest that most readers would be familiar with contains a list of layers that are used to build the image. Each layer is a reference to a blob.</p><p>An additional reference outside the layer references is used for storing additional configuration. More info can be found in the official <a href="https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md" target="_blank" rel="noreferrer">OCI Image Manifest spec</a>.</p><p>The term <em>artifact</em> is just a generalization over the Image Manifest idea. The Image Manifest has a specific format that can be found in the aforementioned <a href="https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md" target="_blank" rel="noreferrer">OCI Image Manifest spec</a>. The important field is the <code>.config.mediaType</code> field. Based on the official guidelines, it can be used for defining types other than an image. More info can be found <a href="https://github.com/opencontainers/image-spec/blob/main/manifest.md#guidelines-for-artifact-usage" target="_blank" rel="noreferrer">here</a>.</p><p>Combining all of these ideas, we can see that artifacts can be represented by 1 specific object - a manifest. That manifest, based on the media type in the config, can be interpreted by different programs for their specific use case. Eg. a Helm chart. Helm charts specifically have a mediaType of <code>application/vnd.cncf.helm.config.v1+json</code>. Layers, too, have a media type. The media type of a layer when the artifact is a helm chart is one of:</p><ul><li>application/vnd.cncf.helm.config.v1+json</li><li>application/vnd.cncf.helm.chart.content.v1.tar+gzip</li><li>application/vnd.cncf.helm.chart.provenance.v1.prov</li></ul><p>More info specifically on Helm charts as OCI Artifacts can be found here: <a href="https://helm.sh/blog/helm-oci-mediatypes/" target="_blank" rel="noreferrer">Helm OCI MediaTypes</a>.</p><h3 id="tags" tabindex="-1">Tags <a class="header-anchor" href="#tags" aria-label="Permalink to &quot;Tags&quot;">​</a></h3><p>While manifests and blobs being content addressable is nice, it becomes hard to address them in a human-readable format. Tags allow us to add a reference to a given manifest that differs from the digest of the object.</p><p>Normally, whenever we push an image to a registry, if we don&#39;t give it an explicit tag, the registry would most likely give it the tag <code>latest</code>. This, actually is not mandatory based on the distribution spec. Manifests don&#39;t require that they have a tag.</p><p>Multiple tags can point to the same manifest.</p><h3 id="cosign" tabindex="-1">Cosign <a class="header-anchor" href="#cosign" aria-label="Permalink to &quot;Cosign&quot;">​</a></h3><p>Cosign is generally a part of the bigger project called <a href="https://sigstore.dev/" target="_blank" rel="noreferrer">sigstore</a>. Sigstore is an &quot;open-source project for improving software supply chain security&quot;. It aims for developers to have a hassle-free way to sign their artifacts while leveraging other components that add additional layers of security to the signature process. Eg. Rekor and Fulcio.</p><p>Cosign is a CLI tool aiming to tie all the components of sigstore together. In our specific case, we use it only as a format for creating signatures and then verifying them. In theory, we wouldn&#39;t need to use Cosign for this, but it uses a popular format for the signatures and the libraries help us save work.</p><p>In the context of Lakom, what interests us is how Cosign signs OCI artifacts and how it stores them. The signing process in a nutshell is the following -- <code>Sign(sha256(SimpleSigningPayload(sha256(Image Manifest))))</code>, where:</p><ul><li>Image Manifest is what it says. Just the manifest of the image (artifact).</li><li>sha256 is the hashing algorithm used.</li><li>SimpleSigningPayload is the interesting part here. Instead of just signing the hash of the manifest itself, the hash itself is packed into a JSON doc that is called the <code>SimpleSigningPayload</code>. Example payload:</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;critical&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">           &quot;identity&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">               &quot;docker-reference&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;testing/manifest&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">           &quot;image&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">               &quot;Docker-manifest-digest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sha256:20be...fe55&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">           &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cosign container image signature&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;optional&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">           &quot;creator&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;atomic&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">           &quot;timestamp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1458239713</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>We can see that the hash of the manifest is stored in the <code>Docker-manifest-digest</code>. Now this object is the one that gets signed using our private key. The signed version of this objest is the one that gets stored and gets used for verification.</p><p>Storage of the signature is done via an image manifest that gets uploaded in the same repo as the image, but tagged with <code>sha256-&lt;container-image-digest&gt;.sig</code>. Thus, the signature discovery mechanism is to just fetch the image digest that is tagged with the aforementioned tag.</p><p>More info on this whole process can be found <a href="https://github.com/sigstore/cosign/blob/main/specs/SIGNATURE_SPEC.md" target="_blank" rel="noreferrer">here</a>.</p><p>Lakom relies on the cosign libraries to automate this whole process. When validating an artifact, if we know its digest, we can fetch the signature and verify it. If the signature is valid, we can be sure that the artifact has not been tampered with.</p>`,37)]))}const m=t(n,[["render",o]]);export{g as __pageData,m as default};
